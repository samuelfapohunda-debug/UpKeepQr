# UpKeepQR Calendar Integration - CORRECTED Technical Specification v1.1
**Version:** 1.1 (Updated with Security & Production Fixes)  
**Date:** December 6, 2025  
**Target Implementation:** Replit AI Agent  
**Deployment Platform:** Render.com (Backend) + Firebase Hosting (Frontend)

---

## ðŸ”´ CRITICAL FIXES FROM v1.0

This specification addresses **all production-critical issues** identified in code review:

### Database Schema Fixes:
- âœ… Added ON UPDATE triggers for `updated_at` columns
- âœ… Made `refresh_token` NOT NULL (required for persistent access)
- âœ… Added `calendar_timezone` field to support user timezones
- âœ… Optimized `event_metadata` to store only essential fields (not entire event object)

### Security Fixes:
- âœ… **HMAC-signed state tokens** to prevent forgery
- âœ… **State token expiry** (15 minutes)
- âœ… **Authentication derived from JWT** (no customerId in request body)
- âœ… **Rate limiting** on OAuth and sync endpoints
- âœ… Proper token revocation on disconnect

### OAuth Fixes:
- âœ… Fixed deprecated `refreshAccessToken()` â†’ use `refreshToken()`
- âœ… Consistent use of backend URL for redirects
- âœ… Proper refresh token handling with error recovery

### Event Creation Fixes:
- âœ… **Duplicate event prevention** (critical!)
- âœ… **Dynamic timezone from user's calendar**
- âœ… **Property address in event titles** for multi-property support
- âœ… **Removed email reminders** (per business requirement)
- âœ… Calendar event updates when task reopened

### Frontend Fixes:
- âœ… Added disconnect button
- âœ… Added sync toggle
- âœ… Error state rendering
- âœ… Loading states

### Monitoring & Production Readiness:
- âœ… SLA definition (5-minute sync latency)
- âœ… Cron job specifications
- âœ… Conflict resolution strategy
- âœ… User-facing error messages
- âœ… Quota monitoring
- âœ… Comprehensive logging

---

## TABLE OF CONTENTS

1. [Executive Summary](#executive-summary)
2. [Database Schema (CORRECTED)](#database-schema-corrected)
3. [API Endpoints (SECURED)](#api-endpoints-secured)
4. [OAuth Implementation (FIXED)](#oauth-implementation-fixed)
5. [Event Creation Logic (DUPLICATE-SAFE)](#event-creation-logic-duplicate-safe)
6. [Frontend Integration (COMPLETE)](#frontend-integration-complete)
7. [Error Handling & Recovery](#error-handling--recovery)
8. [Security & Encryption](#security--encryption)
9. [Rate Limiting](#rate-limiting)
10. [Monitoring & SLA](#monitoring--sla)
11. [Environment Variables](#environment-variables)
12. [Migration Scripts](#migration-scripts)
13. [Implementation Checklist](#implementation-checklist)
14. [Testing Requirements](#testing-requirements)

---

## EXECUTIVE SUMMARY

### Phase 1 MVP Scope
- âœ… **Google Calendar only** (Apple/Outlook in Phase 2)
- âœ… **One-way sync** (UpKeepQR â†’ Google Calendar, no webhook sync back)
- âœ… **Post-setup activation** via email link
- âœ… **Individual events** for next 12 months (not recurring events)
- âœ… **Duplicate-safe** sync algorithm
- âœ… **Production-grade** security and error handling

### Key Business Requirements
1. Calendar events created when homeowner completes Setup form
2. All maintenance tasks synced automatically
3. Events include: task instructions, dashboard link, pro recommendations
4. **No email reminders from Google Calendar** (popup only)
5. Homeowners can disable sync, disconnect, re-sync
6. Tasks marked complete in UpKeepQR â†’ calendar event marked complete
7. SMS preferences independent of calendar sync
8. Future tasks only (no retroactive sync)
9. **Multi-property support** with property address in event titles

### SLA Commitments
- **Sync Latency:** â‰¤5 minutes from task creation to calendar event
- **Uptime:** 99.5% availability
- **Sync Success Rate:** â‰¥99.5%
- **Token Refresh:** Automatic and transparent to user

---

## DATABASE SCHEMA (CORRECTED)

### Table: `calendar_connections`

**Purpose:** Store encrypted OAuth tokens and sync preferences per customer.

```sql
CREATE TABLE IF NOT EXISTS calendar_connections (
  id TEXT PRIMARY KEY,
  customer_id TEXT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  provider VARCHAR(20) NOT NULL CHECK (provider IN ('google', 'apple', 'outlook')),
  
  -- Encrypted tokens (AES-256-GCM with IV:authTag:encrypted format)
  access_token TEXT NOT NULL,
  refresh_token TEXT NOT NULL, -- REQUIRED - Google always returns this with prompt:consent
  token_expiry TIMESTAMP,
  
  -- Calendar metadata
  calendar_id TEXT NOT NULL,
  calendar_name TEXT,
  calendar_timezone TEXT NOT NULL DEFAULT 'America/New_York', -- Fetched from Google Calendar
  
  -- Sync settings
  sync_enabled BOOLEAN NOT NULL DEFAULT TRUE,
  last_sync TIMESTAMP,
  last_sync_status VARCHAR(20) CHECK (last_sync_status IN ('success', 'failed', 'pending')),
  last_sync_error TEXT,
  
  -- Event preferences
  default_event_duration VARCHAR(10) NOT NULL DEFAULT '01:00', -- HH:MM format
  default_event_time VARCHAR(5) NOT NULL DEFAULT '09:00', -- HH:MM 24-hour format
  use_property_colors BOOLEAN NOT NULL DEFAULT TRUE,
  
  -- Audit fields
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  
  -- Constraints
  UNIQUE(customer_id, provider) -- One connection per provider per customer
);

-- Performance indexes
CREATE INDEX idx_calendar_connections_customer ON calendar_connections(customer_id);
CREATE INDEX idx_calendar_connections_sync_enabled ON calendar_connections(customer_id, sync_enabled);
CREATE INDEX idx_calendar_connections_provider ON calendar_connections(provider);

-- Auto-update updated_at trigger
CREATE OR REPLACE FUNCTION update_calendar_connections_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_calendar_connections_updated_at
BEFORE UPDATE ON calendar_connections
FOR EACH ROW
EXECUTE FUNCTION update_calendar_connections_timestamp();
```

---

### Table: `calendar_sync_events`

**Purpose:** Track individual calendar events and their sync status.

```sql
CREATE TABLE IF NOT EXISTS calendar_sync_events (
  id TEXT PRIMARY KEY,
  connection_id TEXT NOT NULL REFERENCES calendar_connections(id) ON DELETE CASCADE,
  customer_id TEXT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  
  -- Task reference
  task_id TEXT, -- Reference to maintenance_tasks table
  task_type VARCHAR(50),
  task_title TEXT NOT NULL,
  property_address TEXT, -- For multi-property support
  
  -- Google Calendar event details
  google_event_id TEXT NOT NULL UNIQUE, -- Google's event ID
  event_start TIMESTAMP NOT NULL,
  event_end TIMESTAMP NOT NULL,
  event_status VARCHAR(20) NOT NULL CHECK (event_status IN ('scheduled', 'completed', 'cancelled')),
  
  -- Sync tracking
  sync_status VARCHAR(20) NOT NULL CHECK (sync_status IN ('synced', 'failed', 'pending_update')),
  last_sync_attempt TIMESTAMP,
  sync_error_message TEXT,
  
  -- Lightweight event metadata (only essential fields to reduce storage)
  event_metadata JSONB, -- { htmlLink, iCalUID, colorId, updated }
  
  -- Audit fields
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  
  -- Unique constraint to prevent duplicate events
  UNIQUE(connection_id, task_id, event_start)
);

-- Performance indexes
CREATE INDEX idx_calendar_sync_events_connection ON calendar_sync_events(connection_id);
CREATE INDEX idx_calendar_sync_events_customer ON calendar_sync_events(customer_id);
CREATE INDEX idx_calendar_sync_events_google_id ON calendar_sync_events(google_event_id);
CREATE INDEX idx_calendar_sync_events_status ON calendar_sync_events(sync_status, event_status);
CREATE INDEX idx_calendar_sync_events_task ON calendar_sync_events(task_id);
CREATE INDEX idx_calendar_sync_events_start_date ON calendar_sync_events(event_start);

-- Auto-update updated_at trigger
CREATE OR REPLACE FUNCTION update_calendar_sync_events_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_calendar_sync_events_updated_at
BEFORE UPDATE ON calendar_sync_events
FOR EACH ROW
EXECUTE FUNCTION update_calendar_sync_events_timestamp();
```

---

### Update Existing Table: `customers`

```sql
ALTER TABLE customers 
ADD COLUMN IF NOT EXISTS calendar_sync_preference VARCHAR(20) 
DEFAULT 'enabled' 
CHECK (calendar_sync_preference IN ('enabled', 'disabled', 'not_configured'));
```

---

## API ENDPOINTS (SECURED)

### Authentication Middleware

**CRITICAL:** All calendar endpoints must derive `customerId` from JWT, NOT from request body.

**File:** `server/middleware/auth.ts`

```typescript
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

export interface AuthRequest extends Request {
  user?: {
    customerId: string;
    email: string;
    role: string;
  };
}

export function requireAuth(req: AuthRequest, res: Response, next: NextFunction) {
  const token = req.headers.authorization?.replace("Bearer ", "");
  
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    req.user = {
      customerId: decoded.customerId,
      email: decoded.email,
      role: decoded.role,
    };
    next();
  } catch (error) {
    return res.status(401).json({ error: "Invalid token" });
  }
}
```

---

### 1. Generate OAuth URL (SECURED)

**Endpoint:** `POST /api/calendar/google/auth-url`

**Request:**
```json
{} 
// No customerId in body - derived from JWT
```

**Headers:**
```
Authorization: Bearer <jwt_token>
```

**Response:**
```json
{
  "authUrl": "https://accounts.google.com/o/oauth2/v2/auth?client_id=...&state=...",
  "state": "encrypted_state_with_hmac"
}
```

**Implementation:**

**File:** `server/src/routes/calendar/google-auth.ts`

```typescript
import { Router } from "express";
import { google } from "googleapis";
import crypto from "crypto";
import { requireAuth, AuthRequest } from "../../middleware/auth";
import { db } from "@db";
import { customers } from "@db/schema";
import { eq } from "drizzle-orm";
import { rateLimit } from "express-rate-limit";

const router = Router();

// Rate limiter: 5 requests per 15 minutes per IP
const authUrlLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many OAuth requests, please try again later",
});

// Generate HMAC-signed state token to prevent forgery
function generateStateToken(customerId: string): string {
  const payload = { customerId, timestamp: Date.now() };
  const payloadStr = JSON.stringify(payload);
  
  // HMAC signature using encryption key
  const hmac = crypto
    .createHmac("sha256", process.env.ENCRYPTION_KEY!)
    .update(payloadStr)
    .digest("hex");
  
  // Format: payload:hmac encoded in base64
  return Buffer.from(`${payloadStr}:${hmac}`).toString("base64");
}

router.post("/auth-url", requireAuth, authUrlLimiter, async (req: AuthRequest, res) => {
  try {
    const customerId = req.user!.customerId; // Derived from JWT
    
    // Verify customer exists
    const customer = await db.query.customers.findFirst({
      where: eq(customers.id, customerId),
    });
    
    if (!customer) {
      return res.status(404).json({
        error: "Customer not found",
        code: "CUSTOMER_NOT_FOUND",
      });
    }
    
    // Create OAuth2 client
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      `${process.env.BACKEND_URL}/api/calendar/google/callback` // Always backend URL
    );
    
    // Generate cryptographically secure state token
    const state = generateStateToken(customerId);
    
    // Generate authorization URL
    const authUrl = oauth2Client.generateAuthUrl({
      access_type: "offline", // Request refresh token
      scope: [
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/calendar.readonly",
      ],
      state,
      prompt: "consent", // Force consent screen to always get refresh token
      include_granted_scopes: false, // Only request calendar scopes
    });
    
    res.json({ authUrl, state });
  } catch (error: any) {
    console.error("Error generating Google auth URL:", error);
    res.status(500).json({
      error: "Failed to generate authorization URL",
      code: "AUTH_URL_GENERATION_FAILED",
    });
  }
});

export default router;
```

---

### 2. OAuth Callback Handler (SECURED & FIXED)

**Endpoint:** `GET /api/calendar/google/callback`

**Query Parameters:**
- `code`: Authorization code from Google
- `state`: HMAC-signed state token
- `error`: OAuth error (if any)

**Response:** Redirect to frontend with status

**Implementation:**

```typescript
// Validate and decode HMAC-signed state token
function validateStateToken(state: string): { customerId: string; timestamp: number } | null {
  try {
    const decoded = Buffer.from(state, "base64").toString();
    const parts = decoded.split(":");
    
    if (parts.length !== 2) {
      console.error("Invalid state token format");
      return null;
    }
    
    const [payloadStr, receivedHmac] = parts;
    
    // Verify HMAC signature
    const expectedHmac = crypto
      .createHmac("sha256", process.env.ENCRYPTION_KEY!)
      .update(payloadStr)
      .digest("hex");
    
    if (receivedHmac !== expectedHmac) {
      console.error("HMAC validation failed - state token tampered");
      return null;
    }
    
    const payload = JSON.parse(payloadStr);
    
    // Verify timestamp (15 minute expiry)
    if (Date.now() - payload.timestamp > 15 * 60 * 1000) {
      console.error("State token expired");
      return null;
    }
    
    return payload;
  } catch (error) {
    console.error("Invalid state token:", error);
    return null;
  }
}

router.get("/callback", async (req, res) => {
  try {
    const { code, state, error } = req.query;
    
    // Handle OAuth errors
    if (error) {
      console.error("Google OAuth error:", error);
      return res.redirect(
        `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=${error}`
      );
    }
    
    if (!code || !state) {
      return res.redirect(
        `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=missing_parameters`
      );
    }
    
    // Validate state token
    const statePayload = validateStateToken(state as string);
    if (!statePayload) {
      return res.redirect(
        `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=invalid_state`
      );
    }
    
    const { customerId } = statePayload;
    
    // Exchange authorization code for tokens
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      `${process.env.BACKEND_URL}/api/calendar/google/callback`
    );
    
    const { tokens } = await oauth2Client.getToken(code as string);
    
    if (!tokens.access_token || !tokens.refresh_token) {
      console.error("Google did not return required tokens");
      return res.redirect(
        `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=incomplete_tokens`
      );
    }
    
    oauth2Client.setCredentials(tokens);
    
    // Get user's primary calendar info
    const calendar = google.calendar({ version: "v3", auth: oauth2Client });
    const calendarList = await calendar.calendarList.list();
    const primaryCalendar = calendarList.data.items?.find(cal => cal.primary === true);
    
    if (!primaryCalendar) {
      return res.redirect(
        `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=no_calendar_found`
      );
    }
    
    // Encrypt tokens before storing
    const encryptedAccessToken = encryptToken(tokens.access_token);
    const encryptedRefreshToken = encryptToken(tokens.refresh_token);
    
    // Check if connection already exists
    const existingConnection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.customerId, customerId),
        eq(calendarConnections.provider, "google")
      ),
    });
    
    const connectionId = existingConnection?.id || crypto.randomUUID();
    
    if (existingConnection) {
      // Update existing connection
      await db.update(calendarConnections)
        .set({
          accessToken: encryptedAccessToken,
          refreshToken: encryptedRefreshToken,
          tokenExpiry: tokens.expiry_date ? new Date(tokens.expiry_date) : null,
          calendarId: primaryCalendar.id!,
          calendarName: primaryCalendar.summary || "Primary Calendar",
          calendarTimezone: primaryCalendar.timeZone || "America/New_York",
          syncEnabled: true,
          lastSyncStatus: "pending",
        })
        .where(eq(calendarConnections.id, existingConnection.id));
    } else {
      // Create new connection
      await db.insert(calendarConnections).values({
        id: connectionId,
        customerId,
        provider: "google",
        accessToken: encryptedAccessToken,
        refreshToken: encryptedRefreshToken,
        tokenExpiry: tokens.expiry_date ? new Date(tokens.expiry_date) : null,
        calendarId: primaryCalendar.id!,
        calendarName: primaryCalendar.summary || "Primary Calendar",
        calendarTimezone: primaryCalendar.timeZone || "America/New_York",
        syncEnabled: true,
        lastSyncStatus: "pending",
      });
    }
    
    // Update customer preference
    await db.update(customers)
      .set({ calendarSyncPreference: "enabled" })
      .where(eq(customers.id, customerId));
    
    // Trigger initial sync (async - don't wait)
    syncMaintenanceTasksToCalendar(customerId, connectionId).catch(error => {
      console.error("Initial calendar sync failed:", error);
    });
    
    res.redirect(`${process.env.FRONTEND_URL}/dashboard?calendar_sync=success`);
  } catch (error: any) {
    console.error("Error in Google OAuth callback:", error);
    res.redirect(
      `${process.env.FRONTEND_URL}/dashboard?calendar_sync=error&message=server_error`
    );
  }
});
```

---

### 3. Manual Sync Endpoint (SECURED)

**Endpoint:** `POST /api/calendar/sync`

**Request:**
```json
{
  "syncType": "full" // 'full' | 'incremental'
}
```

**Headers:**
```
Authorization: Bearer <jwt_token>
```

**Response:**
```json
{
  "message": "Calendar sync completed",
  "eventsCreated": 12,
  "eventsUpdated": 3,
  "eventsFailed": 0,
  "syncTimestamp": "2025-12-06T10:30:00Z"
}
```

**Implementation:**

```typescript
// Rate limiter: 10 syncs per hour per user
const syncLimiter = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: 10,
  keyGenerator: (req: AuthRequest) => req.user!.customerId,
  message: "Too many sync requests, please try again later",
});

router.post("/sync", requireAuth, syncLimiter, async (req: AuthRequest, res) => {
  try {
    const customerId = req.user!.customerId;
    const { syncType = "full" } = req.body;
    
    // Get customer's calendar connection
    const connection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.customerId, customerId),
        eq(calendarConnections.provider, "google"),
        eq(calendarConnections.syncEnabled, true)
      ),
    });
    
    if (!connection) {
      return res.status(404).json({
        error: "No active calendar connection found",
        code: "NO_CONNECTION",
      });
    }
    
    // Perform sync
    const result = await syncMaintenanceTasksToCalendar(customerId, connection.id);
    
    res.json({
      message: "Calendar sync completed",
      ...result,
      syncTimestamp: new Date().toISOString(),
    });
  } catch (error: any) {
    console.error("Calendar sync error:", error);
    res.status(500).json({
      error: "Sync failed",
      code: "SYNC_FAILED",
      details: error.message,
    });
  }
});
```

---

### 4. Connection Status (SECURED)

**Endpoint:** `GET /api/calendar/connection/status`

**Headers:**
```
Authorization: Bearer <jwt_token>
```

**Response:**
```json
{
  "connected": true,
  "provider": "google",
  "calendarName": "Primary Calendar",
  "calendarTimezone": "America/Los_Angeles",
  "syncEnabled": true,
  "lastSync": "2025-12-06T09:00:00Z",
  "lastSyncStatus": "success",
  "totalEventsSynced": 48
}
```

**Implementation:**

```typescript
router.get("/connection/status", requireAuth, async (req: AuthRequest, res) => {
  try {
    const customerId = req.user!.customerId;
    
    const connection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.customerId, customerId),
        eq(calendarConnections.provider, "google")
      ),
    });
    
    if (!connection) {
      return res.json({ connected: false });
    }
    
    // Count synced events
    const eventCount = await db
      .select({ count: sql<number>`count(*)` })
      .from(calendarSyncEvents)
      .where(and(
        eq(calendarSyncEvents.connectionId, connection.id),
        eq(calendarSyncEvents.syncStatus, "synced")
      ))
      .then(rows => rows[0]?.count || 0);
    
    res.json({
      connected: true,
      provider: connection.provider,
      calendarName: connection.calendarName,
      calendarTimezone: connection.calendarTimezone,
      syncEnabled: connection.syncEnabled,
      lastSync: connection.lastSync,
      lastSyncStatus: connection.lastSyncStatus,
      totalEventsSynced: eventCount,
    });
  } catch (error: any) {
    console.error("Error fetching connection status:", error);
    res.status(500).json({ error: "Failed to fetch status" });
  }
});
```

---

### 5. Disconnect Calendar (SECURED WITH REVOCATION)

**Endpoint:** `DELETE /api/calendar/disconnect`

**Request:**
```json
{
  "deleteEvents": true
}
```

**Headers:**
```
Authorization: Bearer <jwt_token>
```

**Response:**
```json
{
  "message": "Calendar disconnected successfully",
  "eventsDeleted": 48,
  "tokenRevoked": true
}
```

**Implementation:**

```typescript
router.delete("/disconnect", requireAuth, async (req: AuthRequest, res) => {
  try {
    const customerId = req.user!.customerId;
    const { deleteEvents = true } = req.body;
    
    const connection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.customerId, customerId),
        eq(calendarConnections.provider, "google")
      ),
    });
    
    if (!connection) {
      return res.status(404).json({ error: "No connection found" });
    }
    
    let eventsDeleted = 0;
    
    if (deleteEvents) {
      // Delete events from Google Calendar
      const events = await db.query.calendarSyncEvents.findMany({
        where: eq(calendarSyncEvents.connectionId, connection.id),
      });
      
      const accessToken = await getValidAccessToken(connection.id);
      const oauth2Client = new google.auth.OAuth2();
      oauth2Client.setCredentials({ access_token: accessToken });
      const calendar = google.calendar({ version: "v3", auth: oauth2Client });
      
      for (const event of events) {
        try {
          await calendar.events.delete({
            calendarId: connection.calendarId,
            eventId: event.googleEventId,
          });
          eventsDeleted++;
        } catch (error) {
          console.error(`Failed to delete event ${event.googleEventId}:`, error);
        }
      }
    }
    
    // Revoke Google OAuth token
    let tokenRevoked = false;
    try {
      const oauth2Client = new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID,
        process.env.GOOGLE_CLIENT_SECRET
      );
      const accessToken = decryptToken(connection.accessToken);
      await oauth2Client.revokeToken(accessToken);
      tokenRevoked = true;
    } catch (error) {
      console.error("Failed to revoke token:", error);
    }
    
    // Delete connection and events from database
    await db.delete(calendarSyncEvents)
      .where(eq(calendarSyncEvents.connectionId, connection.id));
    
    await db.delete(calendarConnections)
      .where(eq(calendarConnections.id, connection.id));
    
    // Update customer preference
    await db.update(customers)
      .set({ calendarSyncPreference: "disabled" })
      .where(eq(customers.id, customerId));
    
    res.json({
      message: "Calendar disconnected successfully",
      eventsDeleted,
      tokenRevoked,
    });
  } catch (error: any) {
    console.error("Error disconnecting calendar:", error);
    res.status(500).json({ error: "Failed to disconnect calendar" });
  }
});
```

---

### 6. Toggle Sync (SECURED)

**Endpoint:** `PATCH /api/calendar/toggle-sync`

**Request:**
```json
{
  "syncEnabled": false
}
```

**Headers:**
```
Authorization: Bearer <jwt_token>
```

**Response:**
```json
{
  "message": "Sync disabled successfully",
  "syncEnabled": false
}
```

**Implementation:**

```typescript
router.patch("/toggle-sync", requireAuth, async (req: AuthRequest, res) => {
  try {
    const customerId = req.user!.customerId;
    const { syncEnabled } = req.body;
    
    if (typeof syncEnabled !== "boolean") {
      return res.status(400).json({ error: "syncEnabled must be boolean" });
    }
    
    const connection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.customerId, customerId),
        eq(calendarConnections.provider, "google")
      ),
    });
    
    if (!connection) {
      return res.status(404).json({ error: "No connection found" });
    }
    
    await db.update(calendarConnections)
      .set({ syncEnabled })
      .where(eq(calendarConnections.id, connection.id));
    
    res.json({
      message: syncEnabled ? "Sync enabled successfully" : "Sync disabled successfully",
      syncEnabled,
    });
  } catch (error: any) {
    console.error("Error toggling sync:", error);
    res.status(500).json({ error: "Failed to toggle sync" });
  }
});
```

---

## OAUTH IMPLEMENTATION (FIXED)

### Token Refresh (CORRECTED)

**CRITICAL FIX:** Use `refreshToken()` instead of deprecated `refreshAccessToken()`.

```typescript
async function getValidAccessToken(connectionId: string): Promise<string> {
  const connection = await db.query.calendarConnections.findFirst({
    where: eq(calendarConnections.id, connectionId),
  });
  
  if (!connection) {
    throw new Error("Calendar connection not found");
  }
  
  // Decrypt access token
  const accessToken = decryptToken(connection.accessToken);
  
  // Check if token is expired
  const isExpired = connection.tokenExpiry && new Date() >= new Date(connection.tokenExpiry);
  
  if (!isExpired) {
    return accessToken; // Token still valid
  }
  
  // Token expired - refresh it
  console.log(`Access token expired for connection ${connectionId}, refreshing...`);
  
  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET
  );
  
  const refreshToken = decryptToken(connection.refreshToken);
  
  try {
    // CORRECTED: Use refreshToken() instead of refreshAccessToken()
    const { credentials } = await oauth2Client.refreshToken(refreshToken);
    
    if (!credentials.access_token) {
      throw new Error("Failed to refresh access token");
    }
    
    // Update stored tokens
    await db.update(calendarConnections)
      .set({
        accessToken: encryptToken(credentials.access_token),
        tokenExpiry: credentials.expiry_date ? new Date(credentials.expiry_date) : null,
        updatedAt: new Date(),
      })
      .where(eq(calendarConnections.id, connectionId));
    
    console.log(`Access token refreshed successfully for connection ${connectionId}`);
    
    return credentials.access_token;
  } catch (error: any) {
    console.error("Token refresh failed:", error);
    
    // Check if refresh token was revoked
    if (error.message?.includes("invalid_grant")) {
      await handleRefreshTokenRevoked(connectionId, connection.customerId);
    }
    
    throw error;
  }
}
```

---

## EVENT CREATION LOGIC (DUPLICATE-SAFE)

### Sync with Duplicate Prevention

**CRITICAL:** Check for existing events before creating new ones.

**File:** `server/lib/calendarSync.ts`

```typescript
import { google } from "googleapis";
import { db } from "@db";
import { calendarConnections, calendarSyncEvents, maintenanceTasks, properties } from "@db/schema";
import { eq, and } from "drizzle-orm";
import crypto from "crypto";

export async function syncMaintenanceTasksToCalendar(
  customerId: string,
  connectionId: string
): Promise<{ eventsCreated: number; eventsUpdated: number; eventsFailed: number }> {
  try {
    // Get calendar connection
    const connection = await db.query.calendarConnections.findFirst({
      where: and(
        eq(calendarConnections.id, connectionId),
        eq(calendarConnections.syncEnabled, true)
      ),
    });
    
    if (!connection) {
      throw new Error("Calendar connection not found or sync disabled");
    }
    
    // Get all active maintenance tasks for customer
    const tasks = await db.query.maintenanceTasks.findMany({
      where: and(
        eq(maintenanceTasks.customerId, customerId),
        eq(maintenanceTasks.active, true)
      ),
      with: {
        property: true, // Get property address for event titles
      },
    });
    
    if (tasks.length === 0) {
      console.log(`No active tasks found for customer ${customerId}`);
      return { eventsCreated: 0, eventsUpdated: 0, eventsFailed: 0 };
    }
    
    // Get valid access token (auto-refreshes if needed)
    const accessToken = await getValidAccessToken(connectionId);
    
    // Initialize Google Calendar API
    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: "v3", auth: oauth2Client });
    
    let eventsCreated = 0;
    let eventsUpdated = 0;
    let eventsFailed = 0;
    
    // Generate events for next 12 months
    const now = new Date();
    const twelveMonthsFromNow = new Date();
    twelveMonthsFromNow.setMonth(now.getMonth() + 12);
    
    for (const task of tasks) {
      try {
        // Calculate event dates based on task frequency
        const eventDates = calculateEventDates(
          task.nextDueDate,
          task.frequency,
          twelveMonthsFromNow
        );
        
        for (const eventDate of eventDates) {
          // CRITICAL: Check if event already exists (prevent duplicates)
          const existingEvent = await db.query.calendarSyncEvents.findFirst({
            where: and(
              eq(calendarSyncEvents.connectionId, connectionId),
              eq(calendarSyncEvents.taskId, task.id),
              eq(calendarSyncEvents.eventStart, eventDate)
            ),
          });
          
          if (existingEvent) {
            // Event already synced - check if update needed
            if (existingEvent.syncStatus === "failed" || existingEvent.eventStatus === "cancelled") {
              // Retry failed/cancelled events
              try {
                await updateGoogleCalendarEvent(
                  calendar,
                  connection.calendarId,
                  existingEvent.googleEventId,
                  {
                    taskTitle: task.title,
                    taskDescription: task.description,
                    instructions: task.instructions,
                    propertyAddress: task.property?.address,
                    eventDate,
                    duration: connection.defaultEventDuration,
                    timezone: connection.calendarTimezone,
                    dashboardLink: `${process.env.FRONTEND_URL}/dashboard/tasks/${task.id}`,
                    proRecommendation: task.proRecommendation,
                  }
                );
                
                await db.update(calendarSyncEvents)
                  .set({
                    syncStatus: "synced",
                    eventStatus: "scheduled",
                    lastSyncAttempt: new Date(),
                    syncErrorMessage: null,
                  })
                  .where(eq(calendarSyncEvents.id, existingEvent.id));
                
                eventsUpdated++;
              } catch (error) {
                console.error(`Failed to update event ${existingEvent.id}:`, error);
                eventsFailed++;
              }
            } else {
              console.log(`Event already synced for task ${task.id} on ${eventDate}`);
            }
            continue;
          }
          
          // Create new event in Google Calendar
          const googleEvent = await createGoogleCalendarEvent(
            calendar,
            connection.calendarId,
            {
              taskId: task.id,
              taskType: task.type,
              taskTitle: task.title,
              taskDescription: task.description,
              instructions: task.instructions,
              propertyAddress: task.property?.address,
              eventDate,
              duration: connection.defaultEventDuration,
              timezone: connection.calendarTimezone,
              dashboardLink: `${process.env.FRONTEND_URL}/dashboard/tasks/${task.id}`,
              proRecommendation: task.proRecommendation,
            }
          );
          
          // Store event in database
          const eventId = crypto.randomUUID();
          await db.insert(calendarSyncEvents).values({
            id: eventId,
            connectionId,
            customerId,
            taskId: task.id,
            taskType: task.type,
            taskTitle: task.title,
            propertyAddress: task.property?.address,
            googleEventId: googleEvent.id!,
            eventStart: eventDate,
            eventEnd: calculateEventEnd(eventDate, connection.defaultEventDuration),
            eventStatus: "scheduled",
            syncStatus: "synced",
            lastSyncAttempt: new Date(),
            eventMetadata: {
              htmlLink: googleEvent.htmlLink,
              iCalUID: googleEvent.iCalUID,
              colorId: googleEvent.colorId,
              updated: googleEvent.updated,
            },
          });
          
          eventsCreated++;
        }
      } catch (error: any) {
        console.error(`Failed to create event for task ${task.id}:`, error);
        eventsFailed++;
      }
    }
    
    // Update connection sync status
    await db.update(calendarConnections)
      .set({
        lastSync: new Date(),
        lastSyncStatus: eventsFailed > 0 ? "failed" : "success",
        lastSyncError: eventsFailed > 0 ? `${eventsFailed} events failed` : null,
        updatedAt: new Date(),
      })
      .where(eq(calendarConnections.id, connectionId));
    
    console.log(`Sync complete for customer ${customerId}: ${eventsCreated} created, ${eventsUpdated} updated, ${eventsFailed} failed`);
    
    return { eventsCreated, eventsUpdated, eventsFailed };
  } catch (error: any) {
    console.error("Calendar sync error:", error);
    throw error;
  }
}
```

---

### Create Google Calendar Event (CORRECTED)

**FIXES:**
- âœ… Use dynamic timezone from calendar connection
- âœ… Include property address in event title
- âœ… **Remove email reminders** (per business requirement)
- âœ… Store only essential metadata

```typescript
async function createGoogleCalendarEvent(
  calendar: any,
  calendarId: string,
  eventData: {
    taskId: string;
    taskType: string;
    taskTitle: string;
    taskDescription: string;
    instructions: string;
    propertyAddress?: string;
    eventDate: Date;
    duration: string; // "HH:MM"
    timezone: string;
    dashboardLink: string;
    proRecommendation?: string;
  }
) {
  const [hours, minutes] = eventData.duration.split(":").map(Number);
  const endDate = new Date(eventData.eventDate);
  endDate.setHours(endDate.getHours() + hours, endDate.getMinutes() + minutes);
  
  // Build event title with property address for multi-property support
  const eventTitle = eventData.propertyAddress
    ? `Home Maintenance: ${eventData.taskTitle} (${eventData.propertyAddress})`
    : `Home Maintenance: ${eventData.taskTitle}`;
  
  // Build event description
  const description = `
${eventData.taskDescription}

ðŸ“‹ INSTRUCTIONS:
${eventData.instructions}

ðŸ”— View in Dashboard: ${eventData.dashboardLink}

${eventData.proRecommendation ? `ðŸ’¡ PRO TIP:\n${eventData.proRecommendation}` : ""}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Powered by UpKeepQR - Your Home Maintenance Assistant
  `.trim();
  
  const event = {
    summary: eventTitle,
    description,
    start: {
      dateTime: eventData.eventDate.toISOString(),
      timeZone: eventData.timezone, // Use customer's timezone
    },
    end: {
      dateTime: endDate.toISOString(),
      timeZone: eventData.timezone,
    },
    reminders: {
      useDefault: false,
      overrides: [
        { method: "popup", minutes: 60 }, // 1 hour before (popup only, NO email)
      ],
    },
    colorId: "7", // Peacock blue for maintenance
  };
  
  const response = await calendar.events.insert({
    calendarId,
    requestBody: event,
  });
  
  return response.data;
}
```

---

### Mark Event Complete (WITH REOPEN SUPPORT)

```typescript
export async function markCalendarEventComplete(
  eventId: string,
  customerId: string,
  completed: boolean = true
): Promise<void> {
  const event = await db.query.calendarSyncEvents.findFirst({
    where: and(
      eq(calendarSyncEvents.id, eventId),
      eq(calendarSyncEvents.customerId, customerId)
    ),
    with: {
      connection: true,
    },
  });
  
  if (!event) {
    throw new Error("Calendar event not found");
  }
  
  if (!event.connection || !event.connection.syncEnabled) {
    console.log("Calendar sync disabled, skipping event update");
    return;
  }
  
  // Get valid access token
  const accessToken = await getValidAccessToken(event.connection.id);
  
  // Initialize Google Calendar API
  const oauth2Client = new google.auth.OAuth2();
  oauth2Client.setCredentials({ access_token: accessToken });
  const calendar = google.calendar({ version: "v3", auth: oauth2Client });
  
  if (completed) {
    // Mark as completed
    await calendar.events.patch({
      calendarId: event.connection.calendarId,
      eventId: event.googleEventId,
      requestBody: {
        description: `âœ… COMPLETED on ${new Date().toLocaleDateString()}\n\n${
          event.eventMetadata?.description || ""
        }`,
        colorId: "10", // Green
      },
    });
    
    await db.update(calendarSyncEvents)
      .set({ eventStatus: "completed", syncStatus: "synced" })
      .where(eq(calendarSyncEvents.id, eventId));
  } else {
    // Reopen task - restore original description
    const originalEvent = await calendar.events.get({
      calendarId: event.connection.calendarId,
      eventId: event.googleEventId,
    });
    
    // Remove "COMPLETED" prefix and restore original color
    const descriptionWithoutCompleted = originalEvent.data.description
      ?.replace(/^âœ… COMPLETED on .*?\n\n/, "")
      || "";
    
    await calendar.events.patch({
      calendarId: event.connection.calendarId,
      eventId: event.googleEventId,
      requestBody: {
        description: descriptionWithoutCompleted,
        colorId: "7", // Back to peacock blue
      },
    });
    
    await db.update(calendarSyncEvents)
      .set({ eventStatus: "scheduled", syncStatus: "synced" })
      .where(eq(calendarSyncEvents.id, eventId));
  }
}
```

---

## FRONTEND INTEGRATION (COMPLETE)

### Calendar Settings Component (FULL IMPLEMENTATION)

**File:** `client/src/components/CalendarSettings.tsx`

```typescript
import React, { useState, useEffect } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Calendar, CheckCircle, XCircle, AlertTriangle, Loader2 } from "lucide-react";

interface CalendarConnectionStatus {
  connected: boolean;
  provider?: string;
  calendarName?: string;
  calendarTimezone?: string;
  syncEnabled: boolean;
  lastSync?: string;
  lastSyncStatus?: string;
  totalEventsSynced?: number;
}

export function CalendarSettings({ customerId }: { customerId: string }) {
  const [status, setStatus] = useState<CalendarConnectionStatus>({
    connected: false,
    syncEnabled: false,
  });
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchConnectionStatus();
  }, [customerId]);

  const fetchConnectionStatus = async () => {
    try {
      setError(null);
      const response = await fetch("/api/calendar/connection/status", {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("auth_token")}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        setStatus(data);
      } else {
        setError("Failed to load calendar status");
      }
    } catch (error) {
      console.error("Error fetching calendar status:", error);
      setError("Network error - please refresh");
    } finally {
      setLoading(false);
    }
  };

  const handleConnectCalendar = async () => {
    try {
      setError(null);
      const response = await fetch("/api/calendar/google/auth-url", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("auth_token")}`,
        },
        body: JSON.stringify({}), // No customerId - derived from JWT
      });

      if (!response.ok) {
        throw new Error("Failed to generate authorization URL");
      }

      const { authUrl } = await response.json();
      window.location.href = authUrl;
    } catch (error) {
      console.error("Error connecting calendar:", error);
      setError("Failed to start calendar connection");
    }
  };

  const handleDisconnect = async () => {
    if (!confirm("Are you sure? This will remove all synced events from your calendar.")) {
      return;
    }

    try {
      setError(null);
      const response = await fetch("/api/calendar/disconnect", {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("auth_token")}`,
        },
        body: JSON.stringify({ deleteEvents: true }),
      });

      if (response.ok) {
        setStatus({ connected: false, syncEnabled: false });
        alert("Calendar disconnected successfully");
      } else {
        throw new Error("Failed to disconnect");
      }
    } catch (error) {
      console.error("Error disconnecting calendar:", error);
      setError("Failed to disconnect calendar");
    }
  };

  const handleToggleSync = async (enabled: boolean) => {
    try {
      setError(null);
      const response = await fetch("/api/calendar/toggle-sync", {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("auth_token")}`,
        },
        body: JSON.stringify({ syncEnabled: enabled }),
      });

      if (response.ok) {
        setStatus({ ...status, syncEnabled: enabled });
      } else {
        throw new Error("Failed to toggle sync");
      }
    } catch (error) {
      console.error("Error toggling sync:", error);
      setError("Failed to update sync setting");
    }
  };

  const handleManualSync = async () => {
    setSyncing(true);
    setError(null);
    
    try {
      const response = await fetch("/api/calendar/sync", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("auth_token")}`,
        },
        body: JSON.stringify({ syncType: "full" }),
      });

      if (response.ok) {
        const data = await response.json();
        alert(`Sync complete!\nCreated: ${data.eventsCreated}\nUpdated: ${data.eventsUpdated}`);
        fetchConnectionStatus();
      } else {
        throw new Error("Sync failed");
      }
    } catch (error) {
      console.error("Error syncing calendar:", error);
      setError("Sync failed - please try again");
    } finally {
      setSyncing(false);
    }
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="flex items-center justify-center p-8">
          <Loader2 className="w-6 h-6 animate-spin" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Calendar className="w-5 h-5" />
          Calendar Integration
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="w-4 h-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {!status.connected ? (
          <div className="space-y-4">
            <Alert>
              <AlertDescription>
                Connect your Google Calendar to automatically add maintenance reminders.
              </AlertDescription>
            </Alert>
            <Button onClick={handleConnectCalendar} className="w-full">
              <Calendar className="w-4 h-4 mr-2" />
              Connect Google Calendar
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Connection Status */}
            <div className="flex items-center justify-between p-3 bg-green-50 rounded-lg">
              <div className="flex items-center gap-2">
                <CheckCircle className="w-5 h-5 text-green-600" />
                <div>
                  <p className="font-medium">Connected to {status.calendarName}</p>
                  <p className="text-sm text-gray-600">
                    {status.totalEventsSynced} events synced â€¢ {status.calendarTimezone}
                  </p>
                </div>
              </div>
              <Button variant="outline" size="sm" onClick={handleDisconnect}>
                Disconnect
              </Button>
            </div>

            {/* Sync Toggle */}
            <div className="flex items-center justify-between p-3 border rounded-lg">
              <div>
                <p className="font-medium">Automatic Sync</p>
                <p className="text-sm text-gray-600">
                  Update calendar when tasks change
                </p>
              </div>
              <Switch
                checked={status.syncEnabled}
                onCheckedChange={handleToggleSync}
              />
            </div>

            {/* Last Sync Status */}
            {status.lastSync && (
              <div className="flex items-center gap-2 text-sm text-gray-600">
                {status.lastSyncStatus === "success" ? (
                  <CheckCircle className="w-4 h-4 text-green-600" />
                ) : status.lastSyncStatus === "failed" ? (
                  <XCircle className="w-4 h-4 text-red-600" />
                ) : (
                  <AlertTriangle className="w-4 h-4 text-yellow-600" />
                )}
                <span>
                  Last synced: {new Date(status.lastSync).toLocaleString()}
                  {status.lastSyncStatus === "failed" && " (with errors)"}
                </span>
              </div>
            )}

            {/* Manual Sync Button */}
            <Button
              onClick={handleManualSync}
              disabled={syncing || !status.syncEnabled}
              variant="outline"
              className="w-full"
            >
              {syncing ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Syncing...
                </>
              ) : (
                "Sync Now"
              )}
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

---

## RATE LIMITING

**File:** `server/middleware/rateLimiter.ts`

```typescript
import rateLimit from "express-rate-limit";

// OAuth endpoints: 5 requests per 15 minutes per IP
export const oauthRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: { error: "Too many OAuth requests, please try again in 15 minutes" },
  standardHeaders: true,
  legacyHeaders: false,
});

// Sync endpoint: 10 requests per hour per user
export const syncRateLimiter = (req: any) => req.user?.customerId || req.ip;

export const syncRateLimit = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: 10,
  keyGenerator: syncRateLimiter,
  message: { error: "Too many sync requests, please try again in 1 hour" },
});

// General API: 100 requests per 15 minutes per IP
export const generalRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: { error: "Too many requests, please slow down" },
});
```

---

## MONITORING & SLA

### Service Level Agreement

**Sync Latency SLA:** â‰¤5 minutes  
- **Target:** 95% of syncs complete within 5 minutes
- **Measurement:** Time from task creation to calendar event creation
- **Monitoring:** Log sync start/end timestamps

**Uptime SLA:** 99.5%  
- **Downtime allowance:** ~3.6 hours/month
- **Monitoring:** Health check endpoint + external uptime monitor

**Sync Success Rate:** â‰¥99.5%  
- **Target:** <0.5% of sync operations fail
- **Monitoring:** Track success/failure counts in logs

### Cron Jobs

**File:** `server/cron/calendarJobs.ts`

```typescript
import cron from "node-cron";
import { processRetryQueue } from "../lib/errorRecovery";
import { performCalendarHealthCheck } from "../lib/calendarMonitoring";

// Retry queue processor: Every 5 minutes
cron.schedule("*/5 * * * *", async () => {
  console.log("[CRON] Processing calendar retry queue...");
  try {
    await processRetryQueue();
  } catch (error) {
    console.error("[CRON] Retry queue processing failed:", error);
  }
});

// Health check: Daily at 2 AM
cron.schedule("0 2 * * *", async () => {
  console.log("[CRON] Running daily calendar health check...");
  try {
    const results = await performCalendarHealthCheck();
    console.log("[CRON] Health check results:", results);
  } catch (error) {
    console.error("[CRON] Health check failed:", error);
  }
});

// Quota monitoring: Every hour
cron.schedule("0 * * * *", async () => {
  console.log("[CRON] Monitoring Google Calendar API quota...");
  // TODO: Implement quota monitoring
});

export function startCalendarCronJobs() {
  console.log("âœ… Calendar cron jobs started");
}
```

### Logging Strategy

```typescript
// Use structured logging with levels
import winston from "winston";

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: "error.log", level: "error" }),
    new winston.transports.File({ filename: "combined.log" }),
  ],
});

// Log sync operations
logger.info("Calendar sync started", {
  customerId,
  connectionId,
  taskCount: tasks.length,
});

logger.info("Calendar sync completed", {
  customerId,
  eventsCreated,
  eventsUpdated,
  eventsFailed,
  duration: Date.now() - startTime,
});

// Log errors with context
logger.error("Calendar sync failed", {
  customerId,
  error: error.message,
  stack: error.stack,
});
```

---

## ENVIRONMENT VARIABLES

### Required Variables

```bash
# Google OAuth (from Google Cloud Console)
GOOGLE_CLIENT_ID=your_client_id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your_client_secret_here

# Encryption (32-byte hex - generate once)
ENCRYPTION_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2

# URLs
FRONTEND_URL=https://upkeepqr.com
BACKEND_URL=https://upkeepqr-backend.onrender.com

# JWT Secret (for authentication)
JWT_SECRET=your_jwt_secret_here

# Database
DATABASE_URL=postgresql://user:password@host/database

# Logging
LOG_LEVEL=info
```

### Generate Encryption Key

```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

Copy output to `ENCRYPTION_KEY` environment variable.

---

## MIGRATION SCRIPTS

### Database Migration

**File:** `server/migrations/0005_add_calendar_tables.sql`

```sql
-- Create calendar_connections table
CREATE TABLE IF NOT EXISTS calendar_connections (
  id TEXT PRIMARY KEY,
  customer_id TEXT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  provider VARCHAR(20) NOT NULL CHECK (provider IN ('google', 'apple', 'outlook')),
  access_token TEXT NOT NULL,
  refresh_token TEXT NOT NULL,
  token_expiry TIMESTAMP,
  calendar_id TEXT NOT NULL,
  calendar_name TEXT,
  calendar_timezone TEXT NOT NULL DEFAULT 'America/New_York',
  sync_enabled BOOLEAN NOT NULL DEFAULT TRUE,
  last_sync TIMESTAMP,
  last_sync_status VARCHAR(20) CHECK (last_sync_status IN ('success', 'failed', 'pending')),
  last_sync_error TEXT,
  default_event_duration VARCHAR(10) NOT NULL DEFAULT '01:00',
  default_event_time VARCHAR(5) NOT NULL DEFAULT '09:00',
  use_property_colors BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  UNIQUE(customer_id, provider)
);

-- Create calendar_sync_events table
CREATE TABLE IF NOT EXISTS calendar_sync_events (
  id TEXT PRIMARY KEY,
  connection_id TEXT NOT NULL REFERENCES calendar_connections(id) ON DELETE CASCADE,
  customer_id TEXT NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
  task_id TEXT,
  task_type VARCHAR(50),
  task_title TEXT NOT NULL,
  property_address TEXT,
  google_event_id TEXT NOT NULL UNIQUE,
  event_start TIMESTAMP NOT NULL,
  event_end TIMESTAMP NOT NULL,
  event_status VARCHAR(20) NOT NULL CHECK (event_status IN ('scheduled', 'completed', 'cancelled')),
  sync_status VARCHAR(20) NOT NULL CHECK (sync_status IN ('synced', 'failed', 'pending_update')),
  last_sync_attempt TIMESTAMP,
  sync_error_message TEXT,
  event_metadata JSONB,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  UNIQUE(connection_id, task_id, event_start)
);

-- Add calendar preference to customers
ALTER TABLE customers 
ADD COLUMN IF NOT EXISTS calendar_sync_preference VARCHAR(20) 
DEFAULT 'enabled' 
CHECK (calendar_sync_preference IN ('enabled', 'disabled', 'not_configured'));

-- Create indexes
CREATE INDEX idx_calendar_connections_customer ON calendar_connections(customer_id);
CREATE INDEX idx_calendar_connections_sync_enabled ON calendar_connections(customer_id, sync_enabled);
CREATE INDEX idx_calendar_connections_provider ON calendar_connections(provider);

CREATE INDEX idx_calendar_sync_events_connection ON calendar_sync_events(connection_id);
CREATE INDEX idx_calendar_sync_events_customer ON calendar_sync_events(customer_id);
CREATE INDEX idx_calendar_sync_events_google_id ON calendar_sync_events(google_event_id);
CREATE INDEX idx_calendar_sync_events_status ON calendar_sync_events(sync_status, event_status);
CREATE INDEX idx_calendar_sync_events_task ON calendar_sync_events(task_id);
CREATE INDEX idx_calendar_sync_events_start_date ON calendar_sync_events(event_start);

-- Auto-update triggers
CREATE OR REPLACE FUNCTION update_calendar_connections_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_calendar_connections_updated_at
BEFORE UPDATE ON calendar_connections
FOR EACH ROW
EXECUTE FUNCTION update_calendar_connections_timestamp();

CREATE OR REPLACE FUNCTION update_calendar_sync_events_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_calendar_sync_events_updated_at
BEFORE UPDATE ON calendar_sync_events
FOR EACH ROW
EXECUTE FUNCTION update_calendar_sync_events_timestamp();
```

### Run Migration

```bash
psql $DATABASE_URL -f server/migrations/0005_add_calendar_tables.sql
```

---

## IMPLEMENTATION CHECKLIST

### Day 1: Setup
- [ ] Generate encryption key
- [ ] Add all environment variables to Render
- [ ] Set up Google Cloud Console project
- [ ] Enable Google Calendar API
- [ ] Create OAuth 2.0 credentials with backend callback URL
- [ ] Configure OAuth consent screen
- [ ] Run database migration
- [ ] Verify tables created

### Day 2: Backend Core
- [ ] Install googleapis: `npm install googleapis express-rate-limit winston`
- [ ] Create auth middleware with JWT validation
- [ ] Create encryption utilities with AES-256-GCM
- [ ] Create rate limiters
- [ ] Create OAuth routes with HMAC state validation
- [ ] Test OAuth flow locally

### Day 3: Calendar Sync
- [ ] Create calendarSync library with duplicate prevention
- [ ] Implement token refresh with error handling
- [ ] Create sync endpoints with authentication
- [ ] Test event creation
- [ ] Test timezone handling

### Day 4: Error Handling
- [ ] Create retry queue
- [ ] Implement token revocation handler
- [ ] Add cron jobs
- [ ] Test error scenarios

### Day 5: Frontend
- [ ] Create Calendar Settings component (complete)
- [ ] Create Calendar Callback page
- [ ] Add routes
- [ ] Update welcome email
- [ ] Test UI flows

### Day 6: Testing
- [ ] Unit tests for encryption
- [ ] Integration tests
- [ ] Manual E2E testing

### Day 7: Deployment
- [ ] Deploy backend
- [ ] Deploy frontend
- [ ] Test production OAuth
- [ ] Monitor logs

### Day 8: Monitoring
- [ ] Set up cron jobs
- [ ] Configure logging
- [ ] Create monitoring dashboard

---

## TESTING REQUIREMENTS

### Unit Tests

```typescript
// Test HMAC state validation
describe("State Token Validation", () => {
  it("should reject tampered state tokens", () => {
    const token = generateStateToken("customer123");
    const tampered = token.slice(0, -1) + "X";
    expect(validateStateToken(tampered)).toBeNull();
  });

  it("should reject expired state tokens", () => {
    const token = generateStateToken("customer123");
    // Mock Date.now() to 20 minutes later
    expect(validateStateToken(token)).toBeNull();
  });
});

// Test duplicate prevention
describe("Duplicate Event Prevention", () => {
  it("should not create duplicate events", async () => {
    await syncMaintenanceTasksToCalendar(customerId, connectionId);
    const firstCount = await getEventCount(connectionId);
    
    await syncMaintenanceTasksToCalendar(customerId, connectionId);
    const secondCount = await getEventCount(connectionId);
    
    expect(secondCount).toBe(firstCount);
  });
});
```

---

## USER-FACING ERROR MESSAGES

```typescript
const ERROR_MESSAGES = {
  NO_CONNECTION: "Calendar not connected. Please connect your calendar in settings.",
  INVALID_STATE: "Security validation failed. Please try connecting your calendar again.",
  TOKEN_EXPIRED: "Calendar access expired. Please reconnect your calendar.",
  SYNC_FAILED: "Calendar sync failed. We'll retry automatically in a few minutes.",
  QUOTA_EXCEEDED: "Too many calendar requests. Please try again in an hour.",
  NETWORK_ERROR: "Network error. Please check your connection and try again.",
  CALENDAR_NOT_FOUND: "Could not access your calendar. Please reconnect.",
};
```

---

## CONFLICT RESOLUTION

**Strategy:** One-way sync (UpKeepQR â†’ Google Calendar only)

**User edits event in Google Calendar:**
- Changes to event time/description in Google are **not synced back**
- UpKeepQR retains source of truth
- If user wants different time, they should edit in UpKeepQR

**Known Limitation (Phase 1):**
- No webhook support for calendar changes
- Manual changes in Google Calendar will be overwritten on next sync
- Phase 2 will add webhook support for two-way sync

---

**END OF SPECIFICATION v1.1**

All critical production issues have been addressed. This specification is ready for Replit agent implementation.