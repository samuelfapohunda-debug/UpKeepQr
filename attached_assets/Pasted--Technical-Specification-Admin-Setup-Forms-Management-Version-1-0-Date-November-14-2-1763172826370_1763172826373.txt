# Technical Specification: Admin Setup Forms Management

**Version:** 1.0  
**Date:** November 14, 2025  
**Target:** Replit AI Agents  
**Estimated Implementation Time:** 3-4 hours

---

## üéØ Overview

Create an admin interface for system administrators to view, edit, and manage customer setup forms at all times. This includes both completed and incomplete setup submissions.

### Business Requirements
- System admins need visibility into all customer setup forms
- Ability to edit customer information and preferences
- Track setup completion status
- Add internal notes for customer records
- Search and filter capabilities

---

## üìã Table of Contents

1. [Authentication & Permissions](#1-authentication--permissions)
2. [Database Schema Updates](#2-database-schema-updates)
3. [API Endpoints](#3-api-endpoints)
4. [Frontend Components](#4-frontend-components)
5. [Implementation Steps](#5-implementation-steps)
6. [Testing Requirements](#6-testing-requirements)

---

## 1. Authentication & Permissions

### 1.1 Role-Based Access Control (Simplified)

**Use ONLY role-based system - no separate permissions table needed.**

```typescript
// shared/schema.ts - User roles
export const userRoleEnum = pgEnum('user_role', [
  'customer',      // Regular customers
  'admin',         // Standard admin - can view orders, customers
  'system_admin'   // Full access - can view/edit setup forms
]);

// Update users table to use role
export const users = pgTable('users', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: varchar('password_hash', { length: 255 }).notNull(),
  role: userRoleEnum('role').default('customer').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull()
});
```

### 1.2 Simple Role Check Middleware

```typescript
// server/lib/auth.ts - Role-based authorization
export function requireRole(allowedRoles: string[]) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const user = req.user; // Assumes user already authenticated
    
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized - Please log in' });
    }
    
    if (!allowedRoles.includes(user.role)) {
      return res.status(403).json({ 
        error: 'Forbidden - Insufficient permissions',
        required: allowedRoles,
        current: user.role
      });
    }
    
    next();
  };
}

// Convenience functions
export const requireSystemAdmin = requireRole(['system_admin']);
export const requireAnyAdmin = requireRole(['admin', 'system_admin']);
```

### 1.3 Grant System Admin Role

```sql
-- Migration: Add system admin role support
-- File: migrations/006_add_system_admin_role.sql

-- Update user role enum to include system_admin
-- Note: If role enum already exists, you may need to alter it
ALTER TYPE user_role ADD VALUE IF NOT EXISTS 'system_admin';

-- Promote specific users to system_admin
-- Replace 'admin@upkeepqr.com' with actual admin emails
UPDATE users 
SET role = 'system_admin' 
WHERE email IN ('admin@upkeepqr.com', 'support@upkeepqr.com');

-- Create index for role lookups
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
```

---

## 2. Database Schema Updates

### 2.1 Database Relationship Cleanup

**CRITICAL: Single source of truth for relationships**

```
Canonical flow:
order_magnet_orders (parent)
    ‚Üì
households.order_id (links to order)
    ‚Üì
home_profile_extras.household_id (links to household)
```

**Remove redundant foreign keys:**
- ‚ùå Remove `households.qrCodeId` (not needed)
- ‚ùå Remove `order_magnet_orders.householdId` (creates circular reference)
- ‚úÖ Keep only `households.order_id` as the link

```sql
-- Migration: Clean up relationships
-- File: migrations/007_cleanup_relationships.sql

-- Remove redundant columns if they exist
ALTER TABLE households DROP COLUMN IF EXISTS qr_code_id;

-- QR codes should link to households (not orders)
-- Add household_id to order_magnet_items if not present
ALTER TABLE order_magnet_items 
ADD COLUMN IF NOT EXISTS household_id UUID REFERENCES households(id);

-- Create index for QR lookup
CREATE INDEX IF NOT EXISTS idx_order_items_household 
ON order_magnet_items(household_id);
```

### 2.2 Add Internal Notes Table

```typescript
// shared/schema.ts
export const setupFormNotes = pgTable('setup_form_notes', {
  id: uuid('id').defaultRandom().primaryKey(),
  householdId: uuid('household_id').references(() => households.id, { onDelete: 'cascade' }).notNull(),
  authorId: uuid('author_id').references(() => users.id, { onDelete: 'set null' }),
  noteText: text('note_text').notNull(),
  deletedAt: timestamp('deleted_at'), // SOFT DELETE support
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const setupFormNotesRelations = relations(setupFormNotes, ({ one }) => ({
  household: one(households, {
    fields: [setupFormNotes.householdId],
    references: [households.id]
  }),
  author: one(users, {
    fields: [setupFormNotes.authorId],
    references: [users.id]
  })
}));
```

### 2.3 Migration SQL for Notes Table

```sql
-- File: migrations/008_create_setup_form_notes.sql

CREATE TABLE IF NOT EXISTS setup_form_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,
  note_text TEXT NOT NULL CHECK (length(note_text) > 0 AND length(note_text) <= 5000),
  deleted_at TIMESTAMP, -- Soft delete support
  created_at TIMESTAMP DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_setup_notes_household ON setup_form_notes(household_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_setup_notes_author ON setup_form_notes(author_id);
CREATE INDEX idx_setup_notes_created ON setup_form_notes(created_at DESC) WHERE deleted_at IS NULL;
```

### 2.4 Add Setup Status Tracking & Search Indexes

```sql
-- File: migrations/009_add_setup_status_and_indexes.sql

-- Add status tracking fields
ALTER TABLE households 
ADD COLUMN IF NOT EXISTS setup_status VARCHAR(20) DEFAULT 'incomplete' 
CHECK (setup_status IN ('incomplete', 'complete'));

ALTER TABLE households
ADD COLUMN IF NOT EXISTS setup_started_at TIMESTAMP;

ALTER TABLE households
ADD COLUMN IF NOT EXISTS last_modified_by UUID REFERENCES users(id) ON DELETE SET NULL;

-- Update existing records
UPDATE households 
SET setup_status = 'complete' 
WHERE setup_completed_at IS NOT NULL AND setup_status = 'incomplete';

-- CRITICAL: Performance indexes for search and filtering
CREATE INDEX IF NOT EXISTS idx_households_setup_status 
ON households(setup_status);

CREATE INDEX IF NOT EXISTS idx_households_completed_date 
ON households(setup_completed_at DESC) WHERE setup_completed_at IS NOT NULL;

-- Composite index for search (name, email, phone)
CREATE INDEX IF NOT EXISTS idx_households_search 
ON households(full_name, email, phone);

-- Composite index for location filtering
CREATE INDEX IF NOT EXISTS idx_households_location 
ON households(state, zipcode);

-- Index for order relationship
CREATE INDEX IF NOT EXISTS idx_households_order 
ON households(order_id);
```

---

## 3. API Endpoints

### 3.1 List All Setup Forms

**Endpoint:** `GET /api/admin/setup-forms`

**Query Parameters:**
- `page` (number, default: 1)
- `limit` (number, default: 50)
- `search` (string, optional) - searches name, email, phone
- `status` (string, optional) - 'complete' | 'incomplete'
- `startDate` (ISO date, optional) - filter by setup_completed_at >= startDate
- `endDate` (ISO date, optional) - filter by setup_completed_at <= endDate
- `state` (string, optional) - filter by state
- `zipcode` (string, optional) - filter by zipcode
- `sortBy` (string, default: 'setup_completed_at')
- `sortOrder` (string, default: 'desc') - 'asc' | 'desc'

**Response:**
```typescript
{
  data: Array<{
    id: string;
    fullName: string;
    email: string;
    phone: string;
    setupStatus: 'complete' | 'incomplete';
    setupCompletedAt: string | null;
    setupStartedAt: string | null;
    notificationPreference: 'email_only' | 'sms_only' | 'both';
    address: {
      line1: string;
      line2: string | null;
      city: string;
      state: string;
      zipcode: string;
    };
    orderId: string | null;
    qrCodeId: string | null;
  }>;
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}
```

**Implementation:**

```typescript
// server/src/routes/admin/setupForms.ts
import { Router } from 'express';
import { db } from '../../db';
import { households, homeProfileExtras, orderMagnetOrders } from '../../../shared/schema';
import { eq, and, or, like, gte, lte, desc, asc } from 'drizzle-orm';
import { requirePermission } from '../../lib/auth';

const router = Router();

router.get('/setup-forms', requireSystemAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      search,
      status,
      startDate,
      endDate,
      state,
      zipcode,
      sortBy = 'setup_completed_at',
      sortOrder = 'desc'
    } = req.query;

    // Validate pagination
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.min(100, Math.max(1, Number(limit))); // Max 100 per page

    // Build WHERE conditions
    const conditions = [];

    // Status filter
    if (status && (status === 'complete' || status === 'incomplete')) {
      conditions.push(eq(households.setupStatus, status as string));
    }

    // Date range filter
    if (startDate) {
      conditions.push(gte(households.setupCompletedAt, new Date(startDate as string)));
    }
    if (endDate) {
      conditions.push(lte(households.setupCompletedAt, new Date(endDate as string)));
    }

    // State filter
    if (state && typeof state === 'string' && state.length === 2) {
      conditions.push(eq(households.state, state.toUpperCase()));
    }

    // Zipcode filter
    if (zipcode && typeof zipcode === 'string') {
      conditions.push(eq(households.zipcode, zipcode));
    }

    // Search filter (name, email, phone)
    if (search && typeof search === 'string' && search.trim()) {
      const searchTerm = `%${search.trim()}%`;
      conditions.push(
        or(
          like(households.fullName, searchTerm),
          like(households.email, searchTerm),
          like(households.phone, searchTerm)
        )
      );
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Get total count for pagination
    const totalResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(households)
      .where(whereClause);
    
    const total = Number(totalResult[0].count);
    const totalPages = Math.ceil(total / limitNum);

    // Prevent page overflow
    const safePage = Math.min(pageNum, Math.max(1, totalPages));

    // Get paginated data
    const offset = (safePage - 1) * limitNum;
    const sortColumn = sortBy === 'setup_completed_at' 
      ? households.setupCompletedAt 
      : households[sortBy as keyof typeof households] || households.setupCompletedAt;
    
    const orderFn = sortOrder === 'asc' ? asc : desc;

    const results = await db
      .select({
        id: households.id,
        fullName: households.fullName,
        email: households.email,
        phone: households.phone,
        setupStatus: households.setupStatus,
        setupCompletedAt: households.setupCompletedAt,
        setupStartedAt: households.setupStartedAt,
        notificationPreference: households.notificationPreference,
        addressLine1: households.addressLine1,
        addressLine2: households.addressLine2,
        city: households.city,
        state: households.state,
        zipcode: households.zipcode,
        orderId: households.orderId
      })
      .from(households)
      .where(whereClause)
      .orderBy(orderFn(sortColumn))
      .limit(limitNum)
      .offset(offset);

    // Format response
    const data = results.map(row => ({
      id: row.id,
      fullName: row.fullName,
      email: row.email,
      phone: row.phone,
      setupStatus: row.setupStatus,
      setupCompletedAt: row.setupCompletedAt?.toISOString() || null,
      setupStartedAt: row.setupStartedAt?.toISOString() || null,
      notificationPreference: row.notificationPreference,
      address: {
        line1: row.addressLine1,
        line2: row.addressLine2,
        city: row.city,
        state: row.state,
        zipcode: row.zipcode
      },
      orderId: row.orderId
    }));

    res.json({
      data,
      pagination: {
        total,
        page: safePage,
        limit: limitNum,
        totalPages: totalPages || 1
      }
    });

  } catch (error) {
    console.error('Error fetching setup forms:', error);
    res.status(500).json({ error: 'Failed to fetch setup forms' });
  }
});

export default router;
```

### 3.2 Get Single Setup Form Details

**Endpoint:** `GET /api/admin/setup-forms/:householdId`

**Response:**
```typescript
{
  id: string;
  fullName: string;
  email: string;
  phone: string;
  
  // Address
  addressLine1: string;
  addressLine2: string | null;
  city: string;
  state: string;
  zipcode: string;
  
  // Notification
  notificationPreference: 'email_only' | 'sms_only' | 'both';
  
  // Home Details (from home_profile_extras)
  homeType: string | null;
  yearBuilt: number | null;
  squareFootage: number | null;
  bedrooms: number | null;
  bathrooms: number | null;
  hvacType: string | null;
  
  // Metadata
  setupStatus: 'complete' | 'incomplete';
  setupCompletedAt: string | null;
  setupStartedAt: string | null;
  lastModifiedAt: string | null;
  lastModifiedBy: {
    id: string;
    email: string;
  } | null;
  
  // Related data
  orderId: string | null;
  qrCodeId: string | null;
  
  // Internal notes
  notes: Array<{
    id: string;
    text: string;
    author: {
      id: string;
      email: string;
    };
    createdAt: string;
    updatedAt: string;
  }>;
}
```

**Implementation:**

```typescript
// server/src/routes/admin/setupForms.ts
router.get('/setup-forms/:householdId', requireSystemAdmin, async (req, res) => {
  try {
    const { householdId } = req.params;

    // Validate UUID
    if (!isValidUUID(householdId)) {
      return res.status(400).json({ error: 'Invalid household ID format' });
    }

    // Fetch household with all related data
    const result = await db.query.households.findFirst({
      where: eq(households.id, householdId),
      with: {
        homeProfileExtras: true,
        notes: {
          where: isNull(setupFormNotes.deletedAt), // Exclude soft-deleted notes
          with: {
            author: {
              columns: {
                id: true,
                email: true
              }
            }
          },
          orderBy: (notes, { desc }) => [desc(notes.createdAt)]
        },
        lastModifiedByUser: {
          columns: {
            id: true,
            email: true
          }
        }
      }
    });

    if (!result) {
      return res.status(404).json({ error: 'Setup form not found' });
    }

    // Fetch order info separately (simplified relationship)
    let orderInfo = null;
    if (result.orderId) {
      orderInfo = await db.query.orderMagnetOrders.findFirst({
        where: eq(orderMagnetOrders.id, result.orderId),
        columns: {
          id: true,
          stripePaymentIntentId: true,
          amountCents: true
        }
      });
    }

    // Format response
    const response = {
      id: result.id,
      fullName: result.fullName,
      email: result.email,
      phone: result.phone,
      addressLine1: result.addressLine1,
      addressLine2: result.addressLine2,
      city: result.city,
      state: result.state,
      zipcode: result.zipcode,
      notificationPreference: result.notificationPreference,
      
      // Home details
      homeType: result.homeProfileExtras?.homeType || null,
      yearBuilt: result.homeProfileExtras?.yearBuilt || null,
      squareFootage: result.homeProfileExtras?.squareFootage || null,
      bedrooms: result.homeProfileExtras?.bedrooms || null,
      bathrooms: result.homeProfileExtras?.bathrooms || null,
      hvacType: result.homeProfileExtras?.hvacType || null,
      
      // Metadata
      setupStatus: result.setupStatus,
      setupCompletedAt: result.setupCompletedAt?.toISOString() || null,
      setupStartedAt: result.setupStartedAt?.toISOString() || null,
      lastModifiedAt: result.updatedAt?.toISOString() || null,
      lastModifiedBy: result.lastModifiedByUser ? {
        id: result.lastModifiedByUser.id,
        email: result.lastModifiedByUser.email
      } : null,
      
      // Related
      orderId: orderInfo?.id || null,
      orderDetails: orderInfo ? {
        stripePaymentIntentId: orderInfo.stripePaymentIntentId,
        amountCents: orderInfo.amountCents
      } : null,
      
      // Notes (excluding soft-deleted)
      notes: result.notes.map(note => ({
        id: note.id,
        text: note.noteText,
        author: note.author ? {
          id: note.author.id,
          email: note.author.email
        } : { id: null, email: 'Unknown' },
        createdAt: note.createdAt.toISOString(),
        updatedAt: note.updatedAt.toISOString()
      }))
    };

    res.json(response);

  } catch (error) {
    console.error('Error fetching setup form:', error);
    res.status(500).json({ error: 'Failed to fetch setup form' });
  }
});
```

### 3.3 Update Setup Form (With Validation & Transactions)

**Endpoint:** `PATCH /api/admin/setup-forms/:householdId`

**Request Body Validation:**
```typescript
import { z } from 'zod';

// Phone regex for US/Canada: +1 followed by 10 digits
const phoneRegex = /^\+1\d{10}$/;

const updateSetupFormSchema = z.object({
  // Customer fields
  fullName: z.string().min(1, 'Name cannot be empty').max(255).optional(),
  email: z.string().email('Invalid email format').optional(),
  phone: z.string().regex(phoneRegex, 'Phone must be E.164 format: +1XXXXXXXXXX').optional(),
  
  // Address fields
  addressLine1: z.string().min(1).max(255).optional(),
  addressLine2: z.string().max(255).nullable().optional(),
  city: z.string().min(1).max(100).optional(),
  state: z.string().length(2, 'State must be 2-letter code (e.g., GA)').toUpperCase().optional(),
  zipcode: z.string().min(5).max(10).regex(/^\d{5}(-\d{4})?$/, 'Invalid zipcode').optional(),
  
  // Notification preference
  notificationPreference: z.enum(['email_only', 'sms_only', 'both']).optional(),
  
  // Home details
  homeType: z.string().max(50).optional(),
  yearBuilt: z.number().int().min(1800).max(new Date().getFullYear() + 1).optional(),
  squareFootage: z.number().int().min(1).max(50000).optional(),
  bedrooms: z.number().int().min(0).max(50).optional(),
  bathrooms: z.number().min(0).max(50).optional(),
  hvacType: z.string().max(100).optional()
}).strict(); // Reject unknown fields
```

**Request Body:**
```typescript
{
  // Any validated fields from schema above
  fullName?: string;
  email?: string;
  // ... etc
}
```

**Response:**
```typescript
{
  success: boolean;
  message: string;
  data: { /* updated household data */ };
}
```

**Implementation with Transaction:**

```typescript
// server/src/routes/admin/setupForms.ts
import { z } from 'zod';

router.patch('/setup-forms/:householdId', 
  requireSystemAdmin, // Changed from requirePermission
  async (req, res) => {
    try {
      const { householdId } = req.params;
      const userId = req.user.id; // Current admin user
      
      // Validate UUID format
      if (!isValidUUID(householdId)) {
        return res.status(400).json({ error: 'Invalid household ID format' });
      }
      
      // Validate request body
      let validatedData;
      try {
        validatedData = updateSetupFormSchema.parse(req.body);
      } catch (error) {
        if (error instanceof z.ZodError) {
          return res.status(400).json({
            error: 'Validation failed',
            details: error.errors.map(e => ({
              field: e.path.join('.'),
              message: e.message
            }))
          });
        }
        throw error;
      }
      
      // Check if household exists
      const existing = await db.query.households.findFirst({
        where: eq(households.id, householdId)
      });
      
      if (!existing) {
        return res.status(404).json({ error: 'Household not found' });
      }
      
      // Separate household updates from home_profile_extras updates
      const householdUpdates: any = {};
      const homeProfileUpdates: any = {};

      // Household fields
      const householdFields = [
        'fullName', 'email', 'phone',
        'addressLine1', 'addressLine2', 'city', 'state', 'zipcode',
        'notificationPreference'
      ];

      // Home profile fields
      const homeProfileFields = [
        'homeType', 'yearBuilt', 'squareFootage',
        'bedrooms', 'bathrooms', 'hvacType'
      ];

      // Separate updates
      Object.keys(validatedData).forEach(key => {
        if (householdFields.includes(key)) {
          householdUpdates[key] = validatedData[key];
        } else if (homeProfileFields.includes(key)) {
          homeProfileUpdates[key] = validatedData[key];
        }
      });

      // TRANSACTION: Update both tables atomically
      const result = await db.transaction(async (trx) => {
        // Update households table
        if (Object.keys(householdUpdates).length > 0) {
          householdUpdates.lastModifiedBy = userId;
          householdUpdates.updatedAt = new Date();
          
          await trx
            .update(households)
            .set(householdUpdates)
            .where(eq(households.id, householdId));
        }

        // Update home_profile_extras table
        if (Object.keys(homeProfileUpdates).length > 0) {
          homeProfileUpdates.updatedAt = new Date();
          
          // Check if record exists
          const existingProfile = await trx.query.homeProfileExtras.findFirst({
            where: eq(homeProfileExtras.householdId, householdId)
          });

          if (existingProfile) {
            await trx
              .update(homeProfileExtras)
              .set(homeProfileUpdates)
              .where(eq(homeProfileExtras.householdId, householdId));
          } else {
            await trx
              .insert(homeProfileExtras)
              .values({
                householdId,
                ...homeProfileUpdates
              });
          }
        }
        
        // Fetch and return updated record
        return await trx.query.households.findFirst({
          where: eq(households.id, householdId),
          with: {
            homeProfileExtras: true
          }
        });
      });

      res.json({
        success: true,
        message: 'Setup form updated successfully',
        data: result
      });

    } catch (error) {
      console.error('Error updating setup form:', error);
      res.status(500).json({ error: 'Failed to update setup form' });
    }
  }
);

// Helper function to validate UUID
function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
```

### 3.4 Add Internal Note (With Validation)

**Endpoint:** `POST /api/admin/setup-forms/:householdId/notes`

**Request Body:**
```typescript
{
  noteText: string; // Required, 1-5000 characters
}
```

**Validation Schema:**
```typescript
const addNoteSchema = z.object({
  noteText: z.string()
    .min(1, 'Note cannot be empty')
    .max(5000, 'Note cannot exceed 5000 characters')
    .trim()
});
```

**Response:**
```typescript
{
  success: boolean;
  note: {
    id: string;
    text: string;
    author: {
      id: string;
      email: string;
    };
    createdAt: string;
  };
}
```

**Implementation:**

```typescript
// server/src/routes/admin/setupForms.ts
router.post('/setup-forms/:householdId/notes', requireSystemAdmin, async (req, res) => {
  try {
    const { householdId } = req.params;
    const userId = req.user.id;

    // Validate UUID
    if (!isValidUUID(householdId)) {
      return res.status(400).json({ error: 'Invalid household ID format' });
    }

    // Validate request body
    let validatedData;
    try {
      validatedData = addNoteSchema.parse(req.body);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        });
      }
      throw error;
    }

    // Check if household exists
    const household = await db.query.households.findFirst({
      where: eq(households.id, householdId)
    });

    if (!household) {
      return res.status(404).json({ error: 'Household not found' });
    }

    // Insert note
    const [newNote] = await db
      .insert(setupFormNotes)
      .values({
        householdId,
        authorId: userId,
        noteText: validatedData.noteText
      })
      .returning();

    // Fetch author details
    const author = await db.query.users.findFirst({
      where: eq(users.id, userId),
      columns: {
        id: true,
        email: true
      }
    });

    res.json({
      success: true,
      note: {
        id: newNote.id,
        text: newNote.noteText,
        author: {
          id: author!.id,
          email: author!.email
        },
        createdAt: newNote.createdAt.toISOString()
      }
    });

  } catch (error) {
    console.error('Error adding note:', error);
    res.status(500).json({ error: 'Failed to add note' });
  }
});

### 3.5 Resend Test Notification (With Rate Limiting)

**Endpoint:** `POST /api/admin/setup-forms/:householdId/resend-test`

**Rate Limit:** 1 request per household per 30 minutes

**Response:**
```typescript
{
  success: boolean;
  message: string;
  channelsUsed?: string[];
  rateLimitRemaining?: number; // seconds until next allowed
}
```

**Implementation with Rate Limiting:**

```typescript
// server/src/routes/admin/setupForms.ts
import { notificationDispatcher } from '../../lib/notificationDispatcher';

// In-memory rate limit cache (use Redis in production)
const testNotificationRateLimit = new Map<string, number>();
const RATE_LIMIT_WINDOW = 30 * 60 * 1000; // 30 minutes in ms

router.post('/setup-forms/:householdId/resend-test', 
  requireSystemAdmin, // Changed from requirePermission
  async (req, res) => {
    try {
      const { householdId } = req.params;

      // Validate UUID
      if (!isValidUUID(householdId)) {
        return res.status(400).json({ error: 'Invalid household ID format' });
      }

      // CHECK RATE LIMIT
      const lastSent = testNotificationRateLimit.get(householdId);
      const now = Date.now();
      
      if (lastSent && (now - lastSent) < RATE_LIMIT_WINDOW) {
        const remainingSeconds = Math.ceil((RATE_LIMIT_WINDOW - (now - lastSent)) / 1000);
        const remainingMinutes = Math.ceil(remainingSeconds / 60);
        
        return res.status(429).json({
          success: false,
          error: 'Rate limit exceeded',
          message: `Please wait ${remainingMinutes} minute(s) before resending test notification`,
          rateLimitRemaining: remainingSeconds
        });
      }

      // Fetch household
      const household = await db.query.households.findFirst({
        where: eq(households.id, householdId)
      });

      if (!household) {
        return res.status(404).json({ error: 'Household not found' });
      }

      // Validate contact info exists
      if (!household.email && !household.phone) {
        return res.status(400).json({
          error: 'No contact information available',
          message: 'Household must have email or phone number to send test notification'
        });
      }

      // Send test notification via unified dispatcher
      const result = await notificationDispatcher.send({
        householdId,
        type: 'test_notification',
        emailSubject: 'Test Notification - UpkeepQR',
        emailHtml: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h1 style="color: #2c5282;">Test Notification</h1>
            <p>Hi ${household.fullName},</p>
            <p>This is a test notification sent by the UpkeepQR system administrator.</p>
            <p>Your notification preferences (${household.notificationPreference}) are working correctly.</p>
            <p style="color: #718096; font-size: 14px; margin-top: 30px;">
              This is an automated test message. No action required.
            </p>
          </div>
        `,
        emailText: `Test Notification - Your notification preferences are working correctly.`,
        smsMessage: `UpkeepQR: This is a test notification from system admin. Your SMS preferences are working correctly.`
      });

      if (result.success) {
        // SET RATE LIMIT - record this send
        testNotificationRateLimit.set(householdId, now);
        
        // Clean up old entries (every 100 requests)
        if (testNotificationRateLimit.size > 100) {
          const cutoff = now - RATE_LIMIT_WINDOW;
          for (const [id, timestamp] of testNotificationRateLimit.entries()) {
            if (timestamp < cutoff) {
              testNotificationRateLimit.delete(id);
            }
          }
        }

        res.json({
          success: true,
          message: 'Test notification sent successfully',
          channelsUsed: result.channelsUsed
        });
      } else {
        res.status(500).json({
          success: false,
          message: 'Failed to send test notification',
          errors: result.errors
        });
      }

    } catch (error) {
      console.error('Error sending test notification:', error);
      res.status(500).json({ error: 'Failed to send test notification' });
    }
  }
);

// Optional: Redis-based rate limiting (production recommendation)
/*
import { createClient } from 'redis';
const redis = createClient();

async function checkRateLimit(key: string, windowMs: number): Promise<boolean> {
  const current = await redis.get(key);
  if (current) {
    const ttl = await redis.ttl(key);
    throw { remaining: ttl }; // Throw remaining time
  }
  await redis.setex(key, Math.ceil(windowMs / 1000), Date.now().toString());
  return true;
}
*/
```

---

## 4. Required Dependencies

### 4.1 Backend Dependencies

```bash
npm install zod
```

**Package:** `zod`  
**Version:** ^3.22.0  
**Purpose:** Request validation and schema definition

**Import usage:**
```typescript
import { z } from 'zod';
```

### 4.2 TypeScript Types

Add to `server/types.d.ts` or create new file:

```typescript
// server/types/express.d.ts
import { User } from '../shared/schema';

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        role: 'customer' | 'admin' | 'system_admin';
      };
    }
  }
}
```

### 4.3 Validation Schemas Collection

Create centralized validation file:

```typescript
// server/lib/validation.ts
import { z } from 'zod';

// Phone regex for US/Canada: +1 followed by 10 digits
const phoneRegex = /^\+1\d{10}$/;

export const updateSetupFormSchema = z.object({
  // Customer fields
  fullName: z.string().min(1, 'Name cannot be empty').max(255).optional(),
  email: z.string().email('Invalid email format').optional(),
  phone: z.string().regex(phoneRegex, 'Phone must be E.164 format: +1XXXXXXXXXX').optional(),
  
  // Address fields
  addressLine1: z.string().min(1).max(255).optional(),
  addressLine2: z.string().max(255).nullable().optional(),
  city: z.string().min(1).max(100).optional(),
  state: z.string().length(2, 'State must be 2-letter code (e.g., GA)').toUpperCase().optional(),
  zipcode: z.string().min(5).max(10).regex(/^\d{5}(-\d{4})?$/, 'Invalid zipcode').optional(),
  
  // Notification preference
  notificationPreference: z.enum(['email_only', 'sms_only', 'both']).optional(),
  
  // Home details
  homeType: z.string().max(50).optional(),
  yearBuilt: z.number().int().min(1800).max(new Date().getFullYear() + 1).optional(),
  squareFootage: z.number().int().min(1).max(50000).optional(),
  bedrooms: z.number().int().min(0).max(50).optional(),
  bathrooms: z.number().min(0).max(50).optional(),
  hvacType: z.string().max(100).optional()
}).strict(); // Reject unknown fields

export const addNoteSchema = z.object({
  noteText: z.string()
    .min(1, 'Note cannot be empty')
    .max(5000, 'Note cannot exceed 5000 characters')
    .trim()
});

// Helper to validate UUID format
export function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
```

---

## 5. Frontend Components

### 4.1 Admin Navigation Update

```typescript
// client/src/components/AdminNav.tsx
import { Link } from 'wouter';

export function AdminNav() {
  return (
    <nav className="admin-nav">
      <Link href="/admin/orders">Orders</Link>
      <Link href="/admin/customers">Customers</Link>
      <Link href="/admin/setup-forms">Setup Forms</Link> {/* NEW */}
      <Link href="/admin/maintenance">Maintenance</Link>
      <Link href="/admin/analytics">Analytics</Link>
    </nav>
  );
}
```

### 4.2 Setup Forms List Page

```typescript
// client/src/pages/admin/SetupFormsList.tsx
import { useState, useEffect } from 'react';
import { Link } from 'wouter';

interface SetupForm {
  id: string;
  fullName: string;
  email: string;
  phone: string;
  setupStatus: 'complete' | 'incomplete';
  setupCompletedAt: string | null;
  notificationPreference: string;
  address: {
    city: string;
    state: string;
    zipcode: string;
  };
}

export function SetupFormsList() {
  const [forms, setForms] = useState<SetupForm[]>([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 50,
    total: 0,
    totalPages: 0
  });

  // Filters
  const [search, setSearch] = useState('');
  const [statusFilter, setStatusFilter] = useState<string>('');
  const [dateRange, setDateRange] = useState<{ start: string; end: string }>({
    start: '',
    end: ''
  });
  const [stateFilter, setStateFilter] = useState('');
  const [zipcodeFilter, setZipcodeFilter] = useState('');

  const fetchForms = async () => {
    setLoading(true);
    try {
      // Build query params
      const params = new URLSearchParams({
        page: pagination.page.toString(),
        limit: pagination.limit.toString()
      });

      if (search) params.append('search', search);
      if (statusFilter) params.append('status', statusFilter);
      if (dateRange.start) params.append('startDate', dateRange.start);
      if (dateRange.end) params.append('endDate', dateRange.end);
      if (stateFilter) params.append('state', stateFilter);
      if (zipcodeFilter) params.append('zipcode', zipcodeFilter);

      const response = await fetch(`/api/admin/setup-forms?${params}`);
      const data = await response.json();

      setForms(data.data);
      setPagination(prev => ({ ...prev, ...data.pagination }));
    } catch (error) {
      console.error('Error fetching setup forms:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchForms();
  }, [
    pagination.page, 
    search, 
    statusFilter, 
    dateRange, 
    stateFilter, 
    zipcodeFilter
  ]);

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    setPagination(prev => ({ ...prev, page: 1 }));
    fetchForms();
  };

  return (
    <div className="setup-forms-list">
      <div className="page-header">
        <h1>Setup Forms</h1>
        <button onClick={fetchForms} className="btn-refresh">
          Refresh
        </button>
      </div>

      {/* Filters Section */}
      <div className="filters-section">
        {/* Search Bar */}
        <form onSubmit={handleSearch} className="search-form">
          <input
            type="text"
            placeholder="Search by name, email, or phone..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="search-input"
          />
          <button type="submit" className="btn-search">Search</button>
        </form>

        {/* Filters Row */}
        <div className="filters-row">
          {/* Status Filter */}
          <select
            value={statusFilter}
            onChange={(e) => setStatusFilter(e.target.value)}
            className="filter-select"
          >
            <option value="">All Status</option>
            <option value="complete">Complete</option>
            <option value="incomplete">Incomplete</option>
          </select>

          {/* Date Range */}
          <div className="date-range">
            <label>From:</label>
            <input
              type="date"
              value={dateRange.start}
              onChange={(e) => setDateRange(prev => ({ ...prev, start: e.target.value }))}
            />
            <label>To:</label>
            <input
              type="date"
              value={dateRange.end}
              onChange={(e) => setDateRange(prev => ({ ...prev, end: e.target.value }))}
            />
          </div>

          {/* State Filter */}
          <input
            type="text"
            placeholder="State (e.g., GA)"
            value={stateFilter}
            onChange={(e) => setStateFilter(e.target.value)}
            className="filter-input"
            maxLength={2}
          />

          {/* Zipcode Filter */}
          <input
            type="text"
            placeholder="Zipcode"
            value={zipcodeFilter}
            onChange={(e) => setZipcodeFilter(e.target.value)}
            className="filter-input"
            maxLength={10}
          />

          {/* Clear Filters */}
          <button
            onClick={() => {
              setSearch('');
              setStatusFilter('');
              setDateRange({ start: '', end: '' });
              setStateFilter('');
              setZipcodeFilter('');
            }}
            className="btn-clear"
          >
            Clear All
          </button>
        </div>
      </div>

      {/* Results Table */}
      {loading ? (
        <div className="loading">Loading...</div>
      ) : (
        <>
          <table className="setup-forms-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Location</th>
                <th>Setup Date</th>
                <th>Status</th>
                <th>Notification Pref</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {forms.map(form => (
                <tr key={form.id}>
                  <td>{form.fullName}</td>
                  <td>{form.email}</td>
                  <td>{form.phone}</td>
                  <td>
                    {form.address.city}, {form.address.state} {form.address.zipcode}
                  </td>
                  <td>
                    {form.setupCompletedAt 
                      ? new Date(form.setupCompletedAt).toLocaleDateString()
                      : 'Not completed'
                    }
                  </td>
                  <td>
                    <span className={`status-badge status-${form.setupStatus}`}>
                      {form.setupStatus === 'complete' ? '‚úì Complete' : '‚è≥ Incomplete'}
                    </span>
                  </td>
                  <td>{form.notificationPreference}</td>
                  <td>
                    <Link href={`/admin/setup-forms/${form.id}`}>
                      <button className="btn-view">View Details</button>
                    </Link>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          {/* Pagination */}
          <div className="pagination">
            <button
              disabled={pagination.page === 1}
              onClick={() => setPagination(prev => ({ ...prev, page: prev.page - 1 }))}
              className="btn-page"
            >
              Previous
            </button>
            <span>
              Page {pagination.page} of {pagination.totalPages} 
              ({pagination.total} total)
            </span>
            <button
              disabled={pagination.page === pagination.totalPages}
              onClick={() => setPagination(prev => ({ ...prev, page: prev.page + 1 }))}
              className="btn-page"
            >
              Next
            </button>
          </div>
        </>
      )}
    </div>
  );
}
```

### 4.3 Setup Form Detail Page

```typescript
// client/src/pages/admin/SetupFormDetail.tsx
import { useState, useEffect } from 'react';
import { useRoute, Link } from 'wouter';

interface SetupFormDetail {
  id: string;
  fullName: string;
  email: string;
  phone: string;
  addressLine1: string;
  addressLine2: string | null;
  city: string;
  state: string;
  zipcode: string;
  notificationPreference: string;
  homeType: string | null;
  yearBuilt: number | null;
  squareFootage: number | null;
  bedrooms: number | null;
  bathrooms: number | null;
  hvacType: string | null;
  setupStatus: string;
  setupCompletedAt: string | null;
  orderId: string | null;
  notes: Array<{
    id: string;
    text: string;
    author: { email: string };
    createdAt: string;
  }>;
}

export function SetupFormDetail() {
  const [, params] = useRoute('/admin/setup-forms/:id');
  const householdId = params?.id;

  const [form, setForm] = useState<SetupFormDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [editing, setEditing] = useState(false);
  const [editedForm, setEditedForm] = useState<Partial<SetupFormDetail>>({});
  const [newNote, setNewNote] = useState('');
  const [savingNote, setSavingNote] = useState(false);

  const fetchForm = async () => {
    try {
      const response = await fetch(`/api/admin/setup-forms/${householdId}`);
      const data = await response.json();
      setForm(data);
      setEditedForm(data);
    } catch (error) {
      console.error('Error fetching form:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (householdId) {
      fetchForm();
    }
  }, [householdId]);

  const handleSave = async () => {
    try {
      const response = await fetch(`/api/admin/setup-forms/${householdId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(editedForm)
      });

      if (response.ok) {
        alert('Setup form updated successfully');
        setEditing(false);
        fetchForm();
      } else {
        alert('Failed to update setup form');
      }
    } catch (error) {
      console.error('Error updating form:', error);
      alert('Error updating setup form');
    }
  };

  const handleAddNote = async () => {
    if (!newNote.trim()) return;

    setSavingNote(true);
    try {
      const response = await fetch(`/api/admin/setup-forms/${householdId}/notes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ noteText: newNote })
      });

      if (response.ok) {
        setNewNote('');
        fetchForm(); // Refresh to show new note
      } else {
        alert('Failed to add note');
      }
    } catch (error) {
      console.error('Error adding note:', error);
      alert('Error adding note');
    } finally {
      setSavingNote(false);
    }
  };

  const handleResendTest = async () => {
    if (!confirm('Send test notification to customer?')) return;

    try {
      const response = await fetch(`/api/admin/setup-forms/${householdId}/resend-test`, {
        method: 'POST'
      });

      const data = await response.json();
      
      if (data.success) {
        alert(`Test notification sent via: ${data.channelsUsed.join(', ')}`);
      } else {
        alert('Failed to send test notification');
      }
    } catch (error) {
      console.error('Error sending test:', error);
      alert('Error sending test notification');
    }
  };

  if (loading) return <div>Loading...</div>;
  if (!form) return <div>Setup form not found</div>;

  return (
    <div className="setup-form-detail">
      <div className="page-header">
        <Link href="/admin/setup-forms">
          <button className="btn-back">‚Üê Back to List</button>
        </Link>
        <h1>Setup Form Details</h1>
        <div className="header-actions">
          {!editing ? (
            <>
              <button onClick={() => setEditing(true)} className="btn-edit">
                Edit
              </button>
              <button onClick={handleResendTest} className="btn-test">
                Resend Test Notification
              </button>
            </>
          ) : (
            <>
              <button onClick={handleSave} className="btn-save">
                Save Changes
              </button>
              <button onClick={() => {
                setEditing(false);
                setEditedForm(form);
              }} className="btn-cancel">
                Cancel
              </button>
            </>
          )}
        </div>
      </div>

      {/* Status Badge */}
      <div className={`status-banner status-${form.setupStatus}`}>
        {form.setupStatus === 'complete' ? '‚úì Setup Complete' : '‚è≥ Setup Incomplete'}
        {form.setupCompletedAt && (
          <span> on {new Date(form.setupCompletedAt).toLocaleString()}</span>
        )}
      </div>

      <div className="form-sections">
        {/* Customer Information Section */}
        <section className="form-section">
          <h2>Customer Information</h2>
          <div className="form-grid">
            <div className="form-field">
              <label>Full Name</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.fullName || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, fullName: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.fullName}</div>
              )}
            </div>

            <div className="form-field">
              <label>Email</label>
              {editing ? (
                <input
                  type="email"
                  value={editedForm.email || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, email: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.email}</div>
              )}
            </div>

            <div className="form-field">
              <label>Phone</label>
              {editing ? (
                <input
                  type="tel"
                  value={editedForm.phone || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, phone: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.phone}</div>
              )}
            </div>

            <div className="form-field">
              <label>Notification Preference</label>
              {editing ? (
                <select
                  value={editedForm.notificationPreference || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, notificationPreference: e.target.value })}
                >
                  <option value="email_only">Email Only</option>
                  <option value="sms_only">SMS Only</option>
                  <option value="both">Both Email and SMS</option>
                </select>
              ) : (
                <div className="field-value">{form.notificationPreference}</div>
              )}
            </div>
          </div>
        </section>

        {/* Address Section */}
        <section className="form-section">
          <h2>Address</h2>
          <div className="form-grid">
            <div className="form-field full-width">
              <label>Address Line 1</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.addressLine1 || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, addressLine1: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.addressLine1}</div>
              )}
            </div>

            <div className="form-field full-width">
              <label>Address Line 2</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.addressLine2 || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, addressLine2: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.addressLine2 || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>City</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.city || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, city: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.city}</div>
              )}
            </div>

            <div className="form-field">
              <label>State</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.state || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, state: e.target.value })}
                  maxLength={2}
                />
              ) : (
                <div className="field-value">{form.state}</div>
              )}
            </div>

            <div className="form-field">
              <label>Zipcode</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.zipcode || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, zipcode: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.zipcode}</div>
              )}
            </div>
          </div>
        </section>

        {/* Home Details Section */}
        <section className="form-section">
          <h2>Home Details</h2>
          <div className="form-grid">
            <div className="form-field">
              <label>Home Type</label>
              {editing ? (
                <select
                  value={editedForm.homeType || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, homeType: e.target.value })}
                >
                  <option value="">Select</option>
                  <option value="Single Family">Single Family</option>
                  <option value="Townhouse">Townhouse</option>
                  <option value="Condo">Condo</option>
                  <option value="Apartment">Apartment</option>
                </select>
              ) : (
                <div className="field-value">{form.homeType || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>Year Built</label>
              {editing ? (
                <input
                  type="number"
                  value={editedForm.yearBuilt || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, yearBuilt: parseInt(e.target.value) })}
                />
              ) : (
                <div className="field-value">{form.yearBuilt || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>Square Footage</label>
              {editing ? (
                <input
                  type="number"
                  value={editedForm.squareFootage || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, squareFootage: parseInt(e.target.value) })}
                />
              ) : (
                <div className="field-value">{form.squareFootage || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>Bedrooms</label>
              {editing ? (
                <input
                  type="number"
                  value={editedForm.bedrooms || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, bedrooms: parseInt(e.target.value) })}
                />
              ) : (
                <div className="field-value">{form.bedrooms || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>Bathrooms</label>
              {editing ? (
                <input
                  type="number"
                  step="0.5"
                  value={editedForm.bathrooms || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, bathrooms: parseFloat(e.target.value) })}
                />
              ) : (
                <div className="field-value">{form.bathrooms || 'N/A'}</div>
              )}
            </div>

            <div className="form-field">
              <label>HVAC Type</label>
              {editing ? (
                <input
                  type="text"
                  value={editedForm.hvacType || ''}
                  onChange={(e) => setEditedForm({ ...editedForm, hvacType: e.target.value })}
                />
              ) : (
                <div className="field-value">{form.hvacType || 'N/A'}</div>
              )}
            </div>
          </div>
        </section>

        {/* Metadata Section */}
        <section className="form-section">
          <h2>Metadata</h2>
          <div className="form-grid">
            <div className="form-field">
              <label>Order ID</label>
              <div className="field-value">{form.orderId || 'N/A'}</div>
            </div>
            <div className="form-field">
              <label>Setup Completed</label>
              <div className="field-value">
                {form.setupCompletedAt 
                  ? new Date(form.setupCompletedAt).toLocaleString()
                  : 'Not completed'
                }
              </div>
            </div>
          </div>
        </section>

        {/* Internal Notes Section */}
        <section className="form-section">
          <h2>Internal Notes</h2>
          
          {/* Add Note Form */}
          <div className="add-note-form">
            <textarea
              placeholder="Add internal note..."
              value={newNote}
              onChange={(e) => setNewNote(e.target.value)}
              rows={3}
              maxLength={5000}
              className="note-textarea"
            />
            <button
              onClick={handleAddNote}
              disabled={savingNote || !newNote.trim()}
              className="btn-add-note"
            >
              {savingNote ? 'Adding...' : 'Add Note'}
            </button>
          </div>

          {/* Notes List */}
          <div className="notes-list">
            {form.notes.length === 0 ? (
              <div className="no-notes">No notes yet</div>
            ) : (
              form.notes.map(note => (
                <div key={note.id} className="note-card">
                  <div className="note-header">
                    <span className="note-author">{note.author.email}</span>
                    <span className="note-date">
                      {new Date(note.createdAt).toLocaleString()}
                    </span>
                  </div>
                  <div className="note-text">{note.text}</div>
                </div>
              ))
            )}
          </div>
        </section>
      </div>
    </div>
  );
}
```

### 4.4 CSS Styles

```css
/* client/src/styles/admin-setup-forms.css */

.setup-forms-list {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.page-header h1 {
  font-size: 2rem;
  color: #1a202c;
}

.btn-refresh {
  padding: 0.5rem 1rem;
  background: #4299e1;
  color: white;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
}

.btn-refresh:hover {
  background: #3182ce;
}

/* Filters Section */
.filters-section {
  background: #f7fafc;
  padding: 1.5rem;
  border-radius: 0.5rem;
  margin-bottom: 2rem;
}

.search-form {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
}

.search-input {
  flex: 1;
  padding: 0.75rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  font-size: 1rem;
}

.btn-search {
  padding: 0.75rem 1.5rem;
  background: #48bb78;
  color: white;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
}

.filters-row {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  align-items: center;
}

.filter-select,
.filter-input {
  padding: 0.5rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
}

.date-range {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.date-range input {
  padding: 0.5rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
}

.btn-clear {
  padding: 0.5rem 1rem;
  background: #e53e3e;
  color: white;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
}

/* Table */
.setup-forms-table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.setup-forms-table th {
  background: #2d3748;
  color: white;
  padding: 1rem;
  text-align: left;
  font-weight: 600;
}

.setup-forms-table td {
  padding: 1rem;
  border-bottom: 1px solid #e2e8f0;
}

.setup-forms-table tbody tr:hover {
  background: #f7fafc;
}

.status-badge {
  display: inline-block;
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.875rem;
  font-weight: 600;
}

.status-complete {
  background: #c6f6d5;
  color: #22543d;
}

.status-incomplete {
  background: #fed7d7;
  color: #742a2a;
}

.btn-view {
  padding: 0.5rem 1rem;
  background: #4299e1;
  color: white;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
}

.btn-view:hover {
  background: #3182ce;
}

/* Pagination */
.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin-top: 2rem;
}

.btn-page {
  padding: 0.5rem 1rem;
  background: white;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  cursor: pointer;
}

.btn-page:hover:not(:disabled) {
  background: #f7fafc;
}

.btn-page:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Detail Page */
.setup-form-detail {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

.status-banner {
  padding: 1rem;
  border-radius: 0.5rem;
  margin-bottom: 2rem;
  font-weight: 600;
}

.header-actions {
  display: flex;
  gap: 1rem;
}

.btn-back,
.btn-edit,
.btn-save,
.btn-cancel,
.btn-test {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
  font-weight: 600;
}

.btn-back {
  background: #e2e8f0;
  color: #2d3748;
}

.btn-edit {
  background: #ed8936;
  color: white;
}

.btn-save {
  background: #48bb78;
  color: white;
}

.btn-cancel {
  background: #e2e8f0;
  color: #2d3748;
}

.btn-test {
  background: #805ad5;
  color: white;
}

.form-sections {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.form-section {
  background: white;
  padding: 2rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.form-section h2 {
  font-size: 1.5rem;
  color: #2d3748;
  margin-bottom: 1.5rem;
  border-bottom: 2px solid #e2e8f0;
  padding-bottom: 0.5rem;
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
}

.form-field.full-width {
  grid-column: 1 / -1;
}

.form-field label {
  display: block;
  font-weight: 600;
  color: #4a5568;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
}

.form-field input,
.form-field select {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  font-size: 1rem;
}

.field-value {
  padding: 0.75rem;
  background: #f7fafc;
  border-radius: 0.375rem;
  color: #2d3748;
  min-height: 2.75rem;
}

/* Notes Section */
.add-note-form {
  display: flex;
  gap: 1rem;
  margin-bottom: 2rem;
}

.note-textarea {
  flex: 1;
  padding: 0.75rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.375rem;
  font-family: inherit;
  resize: vertical;
}

.btn-add-note {
  padding: 0.75rem 1.5rem;
  background: #48bb78;
  color: white;
  border: none;
  border-radius: 0.375rem;
  cursor: pointer;
  align-self: flex-start;
}

.btn-add-note:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.notes-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.note-card {
  background: #f7fafc;
  padding: 1rem;
  border-radius: 0.375rem;
  border-left: 4px solid #4299e1;
}

.note-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  color: #718096;
}

.note-author {
  font-weight: 600;
  color: #2d3748;
}

.note-text {
  color: #2d3748;
  white-space: pre-wrap;
}

.no-notes {
  text-align: center;
  color: #a0aec0;
  padding: 2rem;
}

/* Loading State */
.loading {
  text-align: center;
  padding: 3rem;
  color: #718096;
  font-size: 1.125rem;
}
```

---

## 6. Implementation Steps

### Step 1: Install Dependencies (5 mins)

```bash
npm install zod
```

### Step 2: Database Migrations (30 mins)

```bash
# Run migrations in order
psql -U admin -d upkeepqr -f migrations/006_add_system_admin_role.sql
psql -U admin -d upkeepqr -f migrations/007_cleanup_relationships.sql
psql -U admin -d upkeepqr -f migrations/008_create_setup_form_notes.sql
psql -U admin -d upkeepqr -f migrations/009_add_setup_status_and_indexes.sql
```

### Step 3: Update Shared Schema (15 mins)

```typescript
// shared/schema.ts
// Add new tables and relations as specified in Section 2
```

### Step 4: Create Auth Middleware (15 mins)

```typescript
// server/lib/auth.ts
// Implement requireRole, requireSystemAdmin as specified in Section 1.2
```

### Step 5: Create Validation Module (10 mins)

```typescript
// server/lib/validation.ts
// Copy validation schemas from Section 4.3
```

### Step 6: Create Backend Routes (120 mins)

```typescript
// server/src/routes/admin/setupForms.ts
// Implement all 5 API endpoints as specified in Section 3
```

### Step 7: Add Route to Server (5 mins)

```typescript
// server/src/index.ts
import setupFormsRouter from './routes/admin/setupForms';

app.use('/api/admin', setupFormsRouter);
```

### Step 8: Create Frontend Components (120 mins)

Add search debouncing to prevent API hammering:

```typescript
// client/src/pages/admin/SetupFormsList.tsx
import { useState, useEffect, useCallback } from 'react';
import { debounce } from 'lodash'; // or implement custom debounce

// Debounce search to prevent excessive API calls
const debouncedFetchForms = useCallback(
  debounce((searchValue) => {
    fetchForms(searchValue);
  }, 500),
  []
);

// Use debounced version when search changes
useEffect(() => {
  debouncedFetchForms(search);
}, [search]);
```

### Step 9: Add Routes to Frontend (10 mins)

```typescript
// client/src/App.tsx
import { SetupFormsList } from './pages/admin/SetupFormsList';
import { SetupFormDetail } from './pages/admin/SetupFormDetail';

// Add routes
<Route path="/admin/setup-forms" component={SetupFormsList} />
<Route path="/admin/setup-forms/:id" component={SetupFormDetail} />
```

### Step 10: Add CSS Styles (15 mins)

```typescript
// client/src/styles/admin-setup-forms.css
// Copy styles from Section 5.4
```

### Step 11: Update Admin Navigation (5 mins)

```typescript
// Add "Setup Forms" link to admin menu
```

---

## 7. Testing Requirements

### 6.1 Manual Testing Checklist

**List View:**
- [ ] Navigate to /admin/setup-forms
- [ ] Verify table displays all setup forms
- [ ] Test search by name
- [ ] Test search by email
- [ ] Test search by phone
- [ ] Test status filter (complete/incomplete)
- [ ] Test date range filter
- [ ] Test state filter
- [ ] Test zipcode filter
- [ ] Test pagination (next/previous)
- [ ] Test "Refresh" button
- [ ] Test "Clear All" filters button

**Detail View:**
- [ ] Click "View Details" on a setup form
- [ ] Verify all customer information displays
- [ ] Verify all address fields display
- [ ] Verify all home details display
- [ ] Verify metadata displays (order ID, setup date)
- [ ] Click "Edit" button
- [ ] Modify fields and save
- [ ] Verify changes persist
- [ ] Click "Cancel" while editing
- [ ] Verify changes are discarded

**Notes:**
- [ ] Add a new note
- [ ] Verify note appears in list
- [ ] Verify note shows author email
- [ ] Verify note shows timestamp
- [ ] Verify notes list in reverse chronological order

**Test Notification:**
- [ ] Click "Resend Test Notification"
- [ ] Verify confirmation dialog
- [ ] Verify email/SMS sent based on preference
- [ ] Check notification logs

**Permissions:**
- [ ] Try accessing as non-admin user (should redirect or 403)
- [ ] Verify only users with permission can access
- [ ] Test edit permissions separately

### 6.2 Edge Cases

- [ ] Setup form with no home details (incomplete)
- [ ] Setup form with missing phone number
- [ ] Setup form with very long note (5000 chars)
- [ ] Pagination with 0 results
- [ ] Pagination with 1000+ results
- [ ] Search with no matches
- [ ] Date range with invalid dates
- [ ] Concurrent edits by multiple admins

---

## 7. Deployment Checklist

### Pre-Deployment:
- [ ] Run all database migrations
- [ ] Grant permissions to admin users
- [ ] Test all API endpoints
- [ ] Test frontend components
- [ ] Verify authentication works
- [ ] Check error handling

### Post-Deployment:
- [ ] Verify admin can access /admin/setup-forms
- [ ] Test search and filters in production
- [ ] Monitor API response times
- [ ] Check for any console errors
- [ ] Verify mobile responsiveness

---

## 8. Security Considerations

### Authentication:
- All routes protected by `requirePermission()` middleware
- Users must have `view_setup_forms` or `edit_setup_forms` permission
- Session-based authentication required

### Authorization:
- Check user permissions on every request
- Validate user owns permission before allowing access
- Log all edit actions with user ID

### Data Protection:
- Don't expose sensitive data in API responses
- Sanitize all user inputs before database queries
- Use parameterized queries (Drizzle ORM handles this)
- Validate all form inputs on backend

### Rate Limiting:
- Consider adding rate limiting to API endpoints
- Prevent abuse of resend test notification

---

## 9. Performance Optimizations

### Database:
- Indexes already added in migrations
- Use pagination to limit query size
- Consider caching frequently accessed data

### Frontend:
- Lazy load detail pages
- Debounce search input
- Cache filter results temporarily
- Use React.memo for expensive components

---

## 10. Future Enhancements (v2)

**Not in MVP:**
- Export to CSV/Excel functionality
- Bulk edit capabilities
- Email customer directly from detail page
- SMS customer directly from detail page
- Real-time updates (WebSocket)
- Activity log (who edited what when)
- Delete/archive setup forms
- Restore deleted forms
- Advanced analytics dashboard

---

## 11. Estimated Timeline

| Task | Time (AI Agent) | Time (Human Dev) | Status |
|------|-----------------|------------------|--------|
| Install dependencies | 5 mins | 5 mins | ‚è≥ |
| Database migrations | 30 mins | 45 mins | ‚è≥ |
| Schema updates | 15 mins | 30 mins | ‚è≥ |
| Auth middleware | 15 mins | 30 mins | ‚è≥ |
| Validation module | 10 mins | 20 mins | ‚è≥ |
| Backend API routes | 120 mins | 180 mins | ‚è≥ |
| Frontend list view | 60 mins | 90 mins | ‚è≥ |
| Frontend detail view | 60 mins | 90 mins | ‚è≥ |
| CSS styling | 15 mins | 30 mins | ‚è≥ |
| Testing | 45 mins | 120 mins | ‚è≥ |
| **Total (AI Agent)** | **6 hours** | | |
| **Total (Human Dev)** | | **10.5 hours** | |

**Note:** Original estimate of 4-5 hours was optimistic. Realistic estimate for AI-assisted implementation is 6 hours, accounting for:
- Transaction implementation
- Validation setup with Zod
- Rate limiting logic
- Comprehensive testing
- Debugging edge cases

---

## 12. Critical Optimizations Implemented

**MVP is complete when:**
- [ ] Admin can view list of all setup forms
- [ ] Admin can search by name, email, phone
- [ ] Admin can filter by status, date, state, zipcode
- [ ] Admin can view full setup form details
- [ ] Admin can edit all form fields
- [ ] Admin can add internal notes
- [ ] Admin can resend test notifications
- [ ] All data displays correctly
- [ ] Pagination works
- [ ] Authentication/permissions enforced
- [ ] No console errors
- [ ] Mobile responsive

---

**END OF SPECIFICATION**

**Status:** Ready for Implementation  
**Target:** Replit AI Agents  
**Implementation Time:** 4-5 hours

For questions: support@upkeepqr.com

**Problem:** Dual role + permissions table created confusion  
**Solution:** Use ONLY role-based access (customer, admin, system_admin)  
**Benefit:** Simpler code, no redundant checks

### ‚úÖ 2. Fixed Database Relationships
**Problem:** Circular references (households ‚Üî orders ‚Üî qr_codes)  
**Solution:** Single source of truth: orders ‚Üí households ‚Üí home_details  
**Benefit:** Predictable queries, no orphaned records

### ‚úÖ 3. Performance Indexes
**Problem:** Slow queries on 20k+ setup forms  
**Solution:** Composite indexes for search and filtering  
**Indexes Added:**
- `idx_households_search` (name, email, phone)
- `idx_households_location` (state, zipcode)
- `idx_households_completed_date` (setup_completed_at DESC)

**Benefit:** Sub-500ms query times even at scale

### ‚úÖ 4. Transaction Wrapping
**Problem:** Partial updates could corrupt data  
**Solution:** Atomic transactions for multi-table updates  
**Benefit:** All-or-nothing updates, data integrity guaranteed

### ‚úÖ 5. Zod Validation
**Problem:** Admins could save invalid data  
**Solution:** Server-side schema validation  
**Benefit:** Invalid data rejected before database

### ‚úÖ 6. Rate Limiting
**Problem:** Admins could spam notifications  
**Solution:** 1 test per household per 30 minutes  
**Benefit:** Prevents abuse, protects email/SMS providers

### ‚úÖ 7. Soft Delete for Notes
**Problem:** Accidental note deletion unrecoverable  
**Solution:** `deleted_at` timestamp  
**Benefit:** Notes recoverable, audit trail maintained

---

## 13. Success Criteria

**MVP is complete when:**
- [ ] System admin can view list of all setup forms
- [ ] System admin can search by name, email, phone (debounced)
- [ ] System admin can filter by status, date, state, zipcode
- [ ] System admin can view full setup form details
- [ ] System admin can edit all form fields (validated)
- [ ] System admin can add internal notes (1-5000 chars)
- [ ] System admin can resend test notifications (rate-limited)
- [ ] All validation errors return helpful messages
- [ ] Transactions prevent partial updates
- [ ] Pagination handles overflow gracefully
- [ ] Performance indexes improve query speed
- [ ] Authentication/permissions enforced correctly
- [ ] No console errors in production
- [ ] Mobile responsive UI
- [ ] Soft-deleted notes don't appear

---

**END OF SPECIFICATION - v2.0 (Optimized)**

**Status:** Production-Ready  
**Target:** Replit AI Agents  
**Realistic Implementation Time:** 6 hours (AI) / 10.5 hours (Human)

**Key Improvements from v1:**
1. Simplified to role-based auth (removed permissions table)
2. Fixed circular database relationships
3. Added Zod validation for all inputs
4. Wrapped updates in transactions
5. Added composite performance indexes
6. Implemented rate limiting
7. Added soft delete for notes
8. Added UUID validation
9. Protected pagination overflow
10. Added search debouncing

For questions: support@upkeepqr.com