# TECHNICAL SPECIFICATION: Order ID Format Change

**Project:** UpKeepQr  
**Feature:** Change Order ID Format to Sequential Number-Year Pattern  
**Specification Version:** 1.1 - IMPLEMENTATION READY (ENHANCED)  
**Date:** 2025-11-11  
**Implementation Target:** Replit AI Agent  
**Priority:** MEDIUM  
**Estimated Time:** 2-3 hours

---

## üìö VERSION HISTORY

| Version | Date       | Author           | Description                                  |
|---------|------------|------------------|----------------------------------------------|
| 1.0     | 2025-11-11 | Claude AI        | Initial Implementation Spec                  |
| 1.1     | 2025-11-11 | S. Fapohunda     | Added concurrency handling, fallback logic, automated tests, validation rules, maintenance scripts |

---

## üìã EXECUTIVE SUMMARY

### Objective
Change the Order ID format in the Magnet Orders system from current format to a new sequential format: `{counter}-{year}`

**Examples:**
- First order in 2025: `1-2025`
- Second order in 2025: `2-2025`
- 150th order across all time: `150-2025` (if created in 2025)

### Current State
- Order IDs currently use unknown format (likely UUID or auto-increment integer)
- Displayed in "Magnet Orders" page under "Order ID" column
- No existing orders to migrate (starting fresh)

### New State
- Order IDs will use format: `{counter}-{year}`
- Counter increments continuously (never resets)
- Year is 4-digit format (2025, 2026, etc.)
- Year represents the year the order was created

---

## üéØ REQUIREMENTS

### Functional Requirements

**FR-1: Order ID Format**
- Format: `{counter}-{year}`
- Counter: Sequential integer starting from 1
- Year: 4-digit year (YYYY format)
- Separator: Single hyphen (-)
- Example: `1-2025`, `2-2025`, `150-2025`

**FR-2: Counter Behavior**
- Counter increments by 1 for each new order
- Counter NEVER resets (continuous across years)
- Counter starts at 1 if no orders exist
- Counter continues from max + 1 if orders exist

**FR-3: Year Behavior**
- Year is extracted from order creation timestamp
- Format: 4 digits (2025, not 25)
- Uses UTC timezone (or server timezone - whichever is consistent)

**FR-4: Uniqueness**
- Each Order ID must be globally unique
- No two orders can have the same Order ID
- Counter + Year combination ensures uniqueness

**FR-5: Display**
- Order ID displayed in "Order ID" column on Magnet Orders page
- Order ID displayed in order details/receipts (if applicable)
- Order ID used in customer communications (if applicable)

### Non-Functional Requirements

**NFR-1: Performance**
- Order ID generation must complete in < 100ms
- No race conditions when multiple orders created simultaneously

**NFR-2: Data Integrity**
- Order ID must be set before order is committed to database
- Order ID cannot be changed after creation
- No gaps in counter sequence (ideally)

**NFR-3: Backwards Compatibility**
- System must handle both old and new Order ID formats (if any old orders exist)
- Queries/filters must work with new format

**NFR-4: Concurrency Control** ‚≠ê NEW
- Order ID generation must be **atomic** (indivisible operation)
- No two concurrent sessions can retrieve the same counter value simultaneously
- Implementation strategy (choose one):
  - **Option A (Recommended):** PostgreSQL sequence (`order_id_counter`)
    - Pros: Built-in atomicity, highly performant, zero race conditions
    - Cons: Requires sequence management
  - **Option B:** Explicit table lock (`LOCK TABLE orders IN EXCLUSIVE MODE`)
    - Pros: Simple, works with existing table
    - Cons: Slightly slower under high concurrency
  - **Option C:** Row-level advisory lock (`pg_advisory_lock`)
    - Pros: More granular than table lock
    - Cons: Requires lock management
- **Production Recommendation:** Use PostgreSQL sequence (Option A)
- **Testing Requirement:** Must pass concurrent order creation test (10+ simultaneous requests)

**Rationale for Continuous Counter (Never Reset):**
- **Auditability:** Ensures clear chronological order tracking across fiscal years
- **Collision Avoidance:** Eliminates potential ID collisions during year-end transitions
- **Forensic Analysis:** Simplifies investigation of order patterns and trends
- **Legal/Compliance:** Maintains unbroken chain of custody for financial records
- **Developer Experience:** Simpler logic, fewer edge cases, easier debugging

---

## üèóÔ∏è DATABASE STRUCTURE

### Assumptions (Based on PostgreSQL)

**Table Name:** `orders` or `magnet_orders`

**Relevant Columns:**
```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,                    -- Auto-increment integer (existing)
  order_id VARCHAR(50) UNIQUE NOT NULL,     -- New format: "1-2025"
  customer_name VARCHAR(255),
  total_amount DECIMAL(10,2),
  status VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  -- other columns...
);
```

**Key Points:**
- `order_id` column stores the formatted ID (`1-2025`)
- `id` column remains as internal primary key
- `order_id` has UNIQUE constraint
- `created_at` timestamp used to extract year

---

## üîß IMPLEMENTATION DETAILS

### Step 1: Database Schema Update

**Check Current Schema:**
```sql
-- Check if order_id column exists
SELECT column_name, data_type, character_maximum_length 
FROM information_schema.columns 
WHERE table_name = 'orders' AND column_name = 'order_id';
```

**Migration Script (if order_id doesn't exist):**
```sql
-- Add order_id column if it doesn't exist
ALTER TABLE orders 
ADD COLUMN IF NOT EXISTS order_id VARCHAR(50);

-- Add unique constraint
ALTER TABLE orders 
ADD CONSTRAINT orders_order_id_unique UNIQUE (order_id);

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders(order_id);
```

**Migration Script (if order_id exists but wrong format):**
```sql
-- Modify column to ensure correct size
ALTER TABLE orders 
ALTER COLUMN order_id TYPE VARCHAR(50);

-- Ensure unique constraint exists
ALTER TABLE orders 
DROP CONSTRAINT IF EXISTS orders_order_id_unique;

ALTER TABLE orders 
ADD CONSTRAINT orders_order_id_unique UNIQUE (order_id);
```

### Step 2: Counter Generation Logic

**Location:** Backend order creation endpoint (likely `server/routes.ts` or `server/routes/orders.ts`)

**Production-Ready Function with Concurrency Control:**

```typescript
/**
 * Generates a new Order ID in format: {counter}-{year}
 * Example: 1-2025, 2-2025, 150-2025
 * 
 * This implementation uses PostgreSQL sequence for atomic counter generation
 * Ensures zero race conditions even under high concurrency
 * 
 * @returns Promise<string> - The generated order ID
 * @throws Error if Order ID generation fails or format is invalid
 */
async function generateOrderId(): Promise<string> {
  const db = getDatabase(); // Your database connection
  const logger = getLogger(); // Your logging utility
  
  try {
    // Get the current year (4 digits)
    const currentYear = new Date().getFullYear();
    
    // Get next counter value from sequence (atomic operation)
    const result = await db.query(`
      SELECT nextval('order_id_counter') as counter
    `);
    
    const counter = result.rows[0].counter;
    
    // Format: {counter}-{year}
    const orderId = `${counter}-${currentYear}`;
    
    // Validate format before returning (safety check)
    if (!/^\d{1,10}-\d{4}$/.test(orderId)) {
      logger.error('Invalid Order ID format generated', { orderId, counter, currentYear });
      throw new Error(`Invalid Order ID format generated: ${orderId}`);
    }
    
    logger.info('Order ID generated successfully', { orderId });
    return orderId;
    
  } catch (error) {
    logger.error('Order ID generation failed', { error: error.message, stack: error.stack });
    
    // Fallback strategy (decide based on business requirements)
    // Option A: Generate temporary ID and retry later
    const fallbackId = `TEMP-${Date.now()}`;
    logger.warn('Using fallback Order ID', { fallbackId });
    // Note: You may want to throw error instead of using fallback
    // throw new Error('Failed to generate Order ID');
    
    // Option B: Throw error and reject order creation (recommended)
    throw new Error(`Order ID generation failed: ${error.message}`);
  }
}
```

**Alternative Implementation (without sequence, using table lock):**

```typescript
/**
 * Generates Order ID using table lock for concurrency control
 * Less performant than sequence but works without additional setup
 */
async function generateOrderIdWithLock(): Promise<string> {
  const client = await pool.connect();
  const logger = getLogger();
  
  try {
    // Begin transaction
    await client.query('BEGIN');
    
    // Lock orders table to prevent concurrent access
    await client.query('LOCK TABLE orders IN EXCLUSIVE MODE');
    
    // Get the current year
    const currentYear = new Date().getFullYear();
    
    // Get the highest counter across all orders
    const result = await client.query(`
      SELECT order_id
      FROM orders
      WHERE order_id IS NOT NULL AND order_id ~ '^\d+-\d{4}$'
      ORDER BY 
        CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) DESC
      LIMIT 1
    `);
    
    let nextCounter = 1;
    
    if (result.rows.length > 0) {
      const lastOrderId = result.rows[0].order_id;
      const lastCounter = parseInt(lastOrderId.split('-')[0], 10);
      nextCounter = lastCounter + 1;
    }
    
    // Format: {counter}-{year}
    const orderId = `${nextCounter}-${currentYear}`;
    
    // Validate format
    if (!/^\d{1,10}-\d{4}$/.test(orderId)) {
      throw new Error(`Invalid Order ID format: ${orderId}`);
    }
    
    // Commit transaction (releases lock)
    await client.query('COMMIT');
    
    logger.info('Order ID generated with lock', { orderId });
    return orderId;
    
  } catch (error) {
    // Rollback transaction on error
    await client.query('ROLLBACK');
    logger.error('Order ID generation failed', { error: error.message });
    throw new Error(`Order ID generation failed: ${error.message}`);
  } finally {
    // Always release client back to pool
    client.release();
  }
}
```

**Sequence Setup (Recommended for Production):**

```sql
-- Create sequence for order ID counter
-- This ensures atomic counter increments with zero race conditions
CREATE SEQUENCE IF NOT EXISTS order_id_counter START WITH 1 INCREMENT BY 1;

-- Initialize sequence to current max counter (if orders already exist)
SELECT setval('order_id_counter', 
  COALESCE(
    (SELECT MAX(CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) 
     FROM orders 
     WHERE order_id ~ '^\d+-\d{4}$'
    ), 
    0
  )
);
```

### Step 3: Integration into Order Creation

**Find the Order Creation Endpoint:**

Likely in `server/routes.ts` or `server/routes/orders.ts`:

```typescript
// Example: POST /api/orders or POST /api/magnets/order

app.post('/api/orders', authenticateAdmin, async (req, res) => {
  try {
    const { customer_name, total_amount, items, ...orderData } = req.body;
    
    // GENERATE ORDER ID - ADD THIS
    const orderId = await generateOrderId();
    
    // Create order in database
    const result = await db.query(`
      INSERT INTO orders (
        order_id,           -- ADD THIS
        customer_name,
        total_amount,
        status,
        created_at
      )
      VALUES ($1, $2, $3, $4, NOW())
      RETURNING *
    `, [
      orderId,              // ADD THIS
      customer_name,
      total_amount,
      'new'
    ]);
    
    const order = result.rows[0];
    
    res.json({
      success: true,
      order: order,
      orderId: orderId    // Return formatted Order ID
    });
    
  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({ error: 'Failed to create order' });
  }
});
```

### Step 4: Frontend Display Update

**Location:** `client/src/pages/MagnetDashboard.tsx` (or similar)

**Ensure Order ID is Displayed:**

```typescript
// In the orders table component
<table>
  <thead>
    <tr>
      <th>Order ID</th>
      <th>Customer</th>
      <th>Total Amount</th>
      <th>Status</th>
      <th>Items</th>
      <th>Created</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    {orders.map((order) => (
      <tr key={order.id}>
        <td className="font-mono">{order.order_id}</td>  {/* Display order_id, not id */}
        <td>{order.customer_name}</td>
        <td>${order.total_amount}</td>
        <td>{order.status}</td>
        <td>{order.items?.length || 0}</td>
        <td>{formatDate(order.created_at)}</td>
        <td>
          <button onClick={() => viewOrder(order.id)}>View</button>
        </td>
      </tr>
    ))}
  </tbody>
</table>
```

**Key Points:**
- Display `order.order_id` (formatted ID like "1-2025")
- NOT `order.id` (internal database ID)
- Use monospace font (`font-mono`) for better readability

---

## üß™ TESTING REQUIREMENTS

### Automated Test Coverage ‚≠ê NEW

**Unit Tests:**

```typescript
// tests/unit/orderIdGenerator.test.ts

import { generateOrderId } from '@/server/utils/orderIdGenerator';
import { pool } from '@/server/db';

describe('Order ID Generator', () => {
  
  beforeEach(async () => {
    // Clean test database
    await pool.query('DELETE FROM orders WHERE order_id LIKE \'%-2025\'');
    await pool.query('SELECT setval(\'order_id_counter\', 1, false)');
  });
  
  test('should generate first order ID as 1-{current_year}', async () => {
    const orderId = await generateOrderId();
    const currentYear = new Date().getFullYear();
    expect(orderId).toBe(`1-${currentYear}`);
  });
  
  test('should generate sequential order IDs', async () => {
    const orderId1 = await generateOrderId();
    const orderId2 = await generateOrderId();
    const orderId3 = await generateOrderId();
    
    const currentYear = new Date().getFullYear();
    expect(orderId1).toBe(`1-${currentYear}`);
    expect(orderId2).toBe(`2-${currentYear}`);
    expect(orderId3).toBe(`3-${currentYear}`);
  });
  
  test('should validate Order ID format', async () => {
    const orderId = await generateOrderId();
    expect(orderId).toMatch(/^\d{1,10}-\d{4}$/);
  });
  
  test('should throw error if database is unavailable', async () => {
    // Mock database failure
    jest.spyOn(pool, 'query').mockRejectedValueOnce(new Error('DB connection failed'));
    
    await expect(generateOrderId()).rejects.toThrow('Order ID generation failed');
  });
  
  test('should continue from existing max counter', async () => {
    // Insert orders with counters 1-5
    await pool.query(`INSERT INTO orders (order_id, status) VALUES ('5-2025', 'new')`);
    await pool.query('SELECT setval(\'order_id_counter\', 5)');
    
    const orderId = await generateOrderId();
    expect(orderId).toBe('6-2025');
  });
});
```

**Integration Tests:**

```typescript
// tests/integration/orderCreation.test.ts

import request from 'supertest';
import app from '@/server/app';
import { pool } from '@/server/db';

describe('Order Creation with New Order ID', () => {
  
  let authToken: string;
  
  beforeAll(async () => {
    // Login and get auth token
    const loginRes = await request(app)
      .post('/api/agent/login')
      .send({ email: 'admin@upkeepqr.com' });
    authToken = loginRes.body.token;
  });
  
  beforeEach(async () => {
    await pool.query('DELETE FROM orders WHERE order_id LIKE \'TEST-%\'');
  });
  
  test('should create order with valid Order ID format', async () => {
    const res = await request(app)
      .post('/api/orders')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        customer_name: 'Test Customer',
        total_amount: 29.99,
        status: 'new'
      });
    
    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.order.order_id).toMatch(/^\d+-\d{4}$/);
  });
  
  test('should handle concurrent order creation without duplicates', async () => {
    // Create 10 orders simultaneously
    const promises = Array.from({ length: 10 }, (_, i) =>
      request(app)
        .post('/api/orders')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          customer_name: `Customer ${i}`,
          total_amount: 29.99
        })
    );
    
    const responses = await Promise.all(promises);
    
    // All should succeed
    responses.forEach(res => {
      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
    });
    
    // Extract Order IDs
    const orderIds = responses.map(res => res.body.order.order_id);
    
    // All should be unique
    const uniqueIds = new Set(orderIds);
    expect(uniqueIds.size).toBe(10);
    
    // All should match format
    orderIds.forEach(id => {
      expect(id).toMatch(/^\d+-\d{4}$/);
    });
  });
  
  test('should prevent duplicate Order IDs in database', async () => {
    // Try to manually insert duplicate
    await pool.query(`INSERT INTO orders (order_id, status) VALUES ('999-2025', 'new')`);
    
    // Attempt duplicate should fail
    await expect(
      pool.query(`INSERT INTO orders (order_id, status) VALUES ('999-2025', 'new')`)
    ).rejects.toThrow();
  });
});
```

**Database Validation Tests:**

```typescript
// tests/integration/orderIdValidation.test.ts

import { pool } from '@/server/db';

describe('Order ID Database Constraints', () => {
  
  test('should enforce UNIQUE constraint on order_id', async () => {
    await pool.query(`INSERT INTO orders (order_id, status) VALUES ('TEST-123-2025', 'new')`);
    
    await expect(
      pool.query(`INSERT INTO orders (order_id, status) VALUES ('TEST-123-2025', 'new')`)
    ).rejects.toThrow(/duplicate key value violates unique constraint/);
  });
  
  test('should allow NULL order_id (backwards compatibility)', async () => {
    // This should work for old orders
    await expect(
      pool.query(`INSERT INTO orders (status) VALUES ('new')`)
    ).resolves.not.toThrow();
  });
  
  test('should validate Order ID format in database', async () => {
    // Valid formats
    await expect(
      pool.query(`INSERT INTO orders (order_id, status) VALUES ('1-2025', 'new')`)
    ).resolves.not.toThrow();
    
    // Clean up
    await pool.query(`DELETE FROM orders WHERE order_id = '1-2025'`);
  });
});
```

**CI/CD Integration (GitHub Actions Example):**

```yaml
# .github/workflows/test.yml

name: Order ID Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: upkeepqr_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/upkeepqr_test
      
      - name: Run unit tests
        run: npm test -- tests/unit/orderIdGenerator.test.ts
      
      - name: Run integration tests
        run: npm test -- tests/integration/
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/upkeepqr_test
```

### Manual Testing Checklist

**Test 1: First Order Creation**
```
GIVEN: No orders exist in database
WHEN: Create first order
THEN: Order ID should be "1-2025" (if created in 2025)
```

**Test 2: Sequential Order Creation**
```
GIVEN: One order exists with ID "1-2025"
WHEN: Create second order
THEN: Order ID should be "2-2025"
```

**Test 3: Counter Continuity**
```
GIVEN: 10 orders exist (1-2025 through 10-2025)
WHEN: Create 11th order
THEN: Order ID should be "11-2025"
```

**Test 4: Year Changes**
```
GIVEN: 50 orders exist, last one is "50-2025"
WHEN: Create order in year 2026
THEN: Order ID should be "51-2026" (counter continues, year updates)
```

**Test 5: Concurrent Orders**
```
GIVEN: Multiple orders created simultaneously
WHEN: Orders created at same time
THEN: Each order has unique Order ID, no duplicates
```

**Test 6: Display in UI**
```
GIVEN: Orders with new format exist
WHEN: View "Magnet Orders" page
THEN: Order IDs display as "1-2025", "2-2025", etc. in "Order ID" column
```

**Test 7: Database Uniqueness**
```
GIVEN: Order with ID "5-2025" exists
WHEN: Try to create another order with ID "5-2025"
THEN: Database rejects with unique constraint violation
```

### SQL Test Queries

**Check Order ID Format:**
```sql
-- Verify all Order IDs match pattern {number}-{year}
SELECT order_id, 
       CASE 
         WHEN order_id ~ '^\d+-\d{4}$' THEN 'Valid'
         ELSE 'Invalid'
       END as format_check
FROM orders;
```

**Check Counter Sequence:**
```sql
-- Check for gaps in counter sequence
WITH numbered_orders AS (
  SELECT 
    order_id,
    CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) as counter,
    ROW_NUMBER() OVER (ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) as row_num
  FROM orders
  WHERE order_id IS NOT NULL
)
SELECT 
  counter,
  row_num,
  counter - row_num as gap
FROM numbered_orders
WHERE counter - row_num != 0;

-- Should return no rows if no gaps
```

**Check Uniqueness:**
```sql
-- Find duplicate Order IDs (should be none)
SELECT order_id, COUNT(*) 
FROM orders 
WHERE order_id IS NOT NULL
GROUP BY order_id 
HAVING COUNT(*) > 1;
```

**Get Max Counter:**
```sql
-- Get the highest counter value
SELECT 
  order_id,
  CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) as counter
FROM orders
WHERE order_id IS NOT NULL
ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) DESC
LIMIT 1;
```

---

## üìÅ FILES TO MODIFY

### Backend Files

**1. Database Migration Script** (NEW FILE)
- **Location:** `db/migrations/XXX_add_order_id_format.sql`
- **Purpose:** Add/modify `order_id` column
- **Content:** SQL migration from Step 1

**2. Order ID Generator Function** (NEW FUNCTION)
- **Location:** `server/utils/orderIdGenerator.ts` (NEW FILE)
- **Purpose:** Generate Order ID in new format
- **Content:** `generateOrderId()` function from Step 2

**3. Order Creation Endpoint** (MODIFY)
- **Location:** `server/routes.ts` or `server/routes/orders.ts`
- **Changes:** 
  - Import `generateOrderId` function
  - Call `generateOrderId()` before inserting order
  - Include `order_id` in INSERT statement

### Frontend Files

**4. Magnet Orders Page** (MODIFY)
- **Location:** `client/src/pages/MagnetDashboard.tsx`
- **Changes:**
  - Ensure displaying `order.order_id` (not `order.id`)
  - Add monospace font class for Order ID column
  - Update TypeScript types if needed

**5. Type Definitions** (MODIFY IF NEEDED)
- **Location:** `client/src/types/order.ts` or similar
- **Changes:**
  - Ensure `Order` type includes `order_id: string`

---

## üîÑ IMPLEMENTATION ORDER

**Critical: Follow this exact sequence**

### Phase 1: Database (Backend)

1. **Create Migration Script**
   ```bash
   # Create file: db/migrations/001_add_order_id_format.sql
   ```

2. **Run Migration**
   ```bash
   # Apply migration to database
   psql $DATABASE_URL -f db/migrations/001_add_order_id_format.sql
   ```

3. **Verify Migration**
   ```sql
   -- Check column exists
   \d orders
   ```

### Phase 2: Order ID Generator (Backend)

4. **Create Generator Function**
   ```bash
   # Create file: server/utils/orderIdGenerator.ts
   # Implement generateOrderId() function
   ```

5. **Test Generator in Isolation**
   ```typescript
   // Test script
   const orderId = await generateOrderId();
   console.log('Generated Order ID:', orderId);
   // Should output: "1-2025" (or next available number)
   ```

### Phase 3: Integration (Backend)

6. **Find Order Creation Endpoint**
   ```bash
   # Search for order creation logic
   grep -r "INSERT INTO orders" server/
   grep -r "POST.*orders" server/
   ```

7. **Modify Order Creation**
   - Import `generateOrderId` function
   - Generate Order ID before insert
   - Include `order_id` in INSERT statement
   - Test with Postman or curl

### Phase 4: Frontend Display

8. **Update Magnet Orders Page**
   - Open `client/src/pages/MagnetDashboard.tsx`
   - Find Order ID column
   - Ensure displaying `order.order_id`
   - Add styling (monospace font)

9. **Update TypeScript Types** (if needed)
   - Ensure `Order` interface includes `order_id: string`

### Phase 5: Testing

10. **Run All Tests**
    - Create test orders
    - Verify Order IDs in format "X-2025"
    - Check database for uniqueness
    - Test concurrent creation

11. **Verify Display**
    - View Magnet Orders page
    - Confirm Order IDs show correctly
    - Test sorting/filtering (if applicable)

---

## üêõ TROUBLESHOOTING

### Issue 1: "Column 'order_id' does not exist"

**Cause:** Migration not run or failed
**Solution:**
```sql
-- Manually add column
ALTER TABLE orders ADD COLUMN order_id VARCHAR(50);
ALTER TABLE orders ADD CONSTRAINT orders_order_id_unique UNIQUE (order_id);
```

### Issue 2: Duplicate Order IDs

**Cause:** Race condition in counter generation
**Solution:** Use PostgreSQL sequence or database transaction with lock

```typescript
// Use transaction with lock
async function generateOrderId(): Promise<string> {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query('LOCK TABLE orders IN EXCLUSIVE MODE');
    
    // Generate Order ID logic here
    const orderId = await generateOrderIdLogic(client);
    
    await client.query('COMMIT');
    return orderId;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

### Issue 3: Order ID not displaying in UI

**Cause:** Frontend using wrong field (`order.id` instead of `order.order_id`)
**Solution:** Update frontend to use `order.order_id`

### Issue 4: Counter not incrementing

**Cause:** Query not finding max counter correctly
**Solution:** Check query logic and test with sample data

```sql
-- Debug query
SELECT 
  order_id,
  SPLIT_PART(order_id, '-', 1) as counter_string,
  CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) as counter_int
FROM orders
WHERE order_id IS NOT NULL
ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) DESC;
```

---

## üîê SECURITY CONSIDERATIONS

**SEC-1: Input Validation**
- Order ID generated server-side only (never client-side)
- No user input used in Order ID generation
- Prevents injection attacks

**SEC-2: Database Constraints**
- UNIQUE constraint prevents duplicates
- NOT NULL constraint ensures Order ID always exists
- Validates data integrity

**SEC-3: Access Control**
- Only authenticated admins can create orders
- Order ID visible to admins only (or as configured)

---

## üìä ACCEPTANCE CRITERIA

Feature is complete when:

- [ ] Database migration executed successfully
- [ ] `order_id` column exists with UNIQUE constraint
- [ ] `generateOrderId()` function created and tested
- [ ] Order creation endpoint generates Order ID
- [ ] First order has ID "1-2025" (or appropriate year)
- [ ] Sequential orders increment correctly (1-2025, 2-2025, 3-2025...)
- [ ] Counter continues across years (never resets)
- [ ] Order ID displays in "Order ID" column on Magnet Orders page
- [ ] No duplicate Order IDs in database
- [ ] All test cases pass
- [ ] No TypeScript errors
- [ ] No console errors in browser
- [ ] Counter continues from current max (if orders exist)

---

## üöÄ DEPLOYMENT CHECKLIST

### Pre-Deployment

**Environment Validation:** ‚≠ê NEW

```bash
# Verify environment variables
echo "=== Environment Validation ==="
echo "DATABASE_URL: ${DATABASE_URL:0:30}..." # Show first 30 chars only
echo "NODE_ENV: $NODE_ENV"
echo "JWT_SECRET length: ${#JWT_SECRET} chars"

# Verify database connection
psql $DATABASE_URL -c "SELECT version();" || echo "‚ùå Database connection failed!"

# Verify correct database (production vs staging)
psql $DATABASE_URL -c "SELECT current_database();" || echo "‚ö†Ô∏è  Check database name!"

# Verify Node.js version
node --version  # Should be v18 or higher

# Verify npm packages installed
npm list --depth=0 | grep -E "(express|pg|jsonwebtoken)" || echo "‚ö†Ô∏è  Missing dependencies!"
```

**Pre-Deployment Checklist:**

- [ ] Code reviewed by senior developer
- [ ] All TypeScript errors resolved
- [ ] All automated tests passing (`npm test`)
- [ ] Database migration tested on staging environment
- [ ] Backup of orders table created
- [ ] Rollback plan documented and tested
- [ ] Environment variables validated (see above)
- [ ] Concurrency test passed (10+ simultaneous orders)
- [ ] Load test completed (if applicable)
- [ ] Monitoring/alerting configured

### Deployment Steps

1. **Backup Database**
   ```bash
   pg_dump $DATABASE_URL -t orders > orders_backup_$(date +%Y%m%d).sql
   ```

2. **Run Migration**
   ```bash
   psql $DATABASE_URL -f db/migrations/001_add_order_id_format.sql
   ```

3. **Deploy Backend Code**
   ```bash
   git push origin main
   # Or deploy via Replit
   ```

4. **Deploy Frontend Code**
   ```bash
   cd client && npm run build
   # Deploy built assets
   ```

5. **Verify Deployment**
   - Create test order
   - Check Order ID format
   - View in Magnet Orders page

### Post-Deployment

- [ ] Monitor error logs for 24 hours
- [ ] Verify orders created have correct format
- [ ] Check for any unique constraint violations
- [ ] Confirm UI displays correctly

---

## üîÑ ROLLBACK PLAN

### Rollback Dependencies & Data Integrity ‚≠ê NEW

**Important Note:**
- Existing orders with new format (`{counter}-{year}`) **remain valid** after rollback
- Frontend can still display these Order IDs correctly
- Only **future** orders will use old format (or manual assignment)
- No data loss occurs during rollback

**Rollback Scenarios:**

| Scenario | Action | Data Impact |
|----------|--------|-------------|
| **Backend Only Rollback** | Revert code, keep DB schema | Existing orders with new format display correctly; new orders may fail if code expects order_id |
| **Full Rollback** | Revert code + remove column | Existing orders lose order_id display; still accessible via internal `id` |
| **Frontend Only Rollback** | Revert UI changes | No impact; backend continues generating new format |

**Recommended Rollback Strategy:**
- Keep database schema intact (don't drop `order_id` column)
- Only revert code if critical bug found
- Existing orders maintain their Order IDs
- New orders can temporarily use fallback logic

### Rollback Procedures

If critical issues occur:

### Step 1: Assess Severity

```bash
# Check for critical errors
tail -f /var/log/app.log | grep -i "order id"

# Check database for data integrity
psql $DATABASE_URL -c "SELECT COUNT(*) FROM orders WHERE order_id IS NULL;"

# Check for duplicate Order IDs
psql $DATABASE_URL -c "
  SELECT order_id, COUNT(*) 
  FROM orders 
  WHERE order_id IS NOT NULL
  GROUP BY order_id 
  HAVING COUNT(*) > 1;
"
```

### Step 2: Emergency Rollback (Code Only)
```bash
# Revert backend code
git log --oneline -10  # Find commit before Order ID changes
git revert <commit_hash>
git push origin main

# Restart application
pm2 restart upkeepqr-api
# Or: systemctl restart upkeepqr
```

### Step 3: Database Rollback (if absolutely necessary)

**‚ö†Ô∏è WARNING:** This will remove Order IDs from existing orders

```sql
-- Option A: Remove UNIQUE constraint only (keep data)
ALTER TABLE orders DROP CONSTRAINT IF EXISTS orders_order_id_unique;

-- Option B: Drop column entirely (data loss)
-- ONLY do this if no orders have been created yet
ALTER TABLE orders DROP COLUMN IF EXISTS order_id;

-- Option C: Drop sequence
DROP SEQUENCE IF EXISTS order_id_counter;
```

### Step 4: Verify Rollback

```bash
# Check application logs
tail -f /var/log/app.log

# Test order creation
curl -X POST http://localhost:5000/api/orders \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"customer_name":"Test","total_amount":29.99}'

# Verify database state
psql $DATABASE_URL -c "\d orders"  # Check schema
```

**Risk Level:** üü° MEDIUM
- Database schema change (reversible)
- Existing orders not affected (no migration of old data)
- New orders use new format

---

## üõ†Ô∏è MAINTENANCE SCRIPTS ‚≠ê NEW

### Sequence Maintenance

```sql
-- Reset sequence to match max counter in database
-- Use this if sequence gets out of sync due to manual DB edits
SELECT setval('order_id_counter', 
  COALESCE(
    (SELECT MAX(CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) 
     FROM orders 
     WHERE order_id ~ '^\d+-\d{4}$'
    ), 
    0
  )
);

-- Check current sequence value
SELECT currval('order_id_counter');

-- Check next sequence value (without incrementing)
SELECT nextval('order_id_counter');
-- NOTE: This WILL increment! Use currval() to just check

-- Alternative: peek at next value without incrementing
SELECT last_value FROM order_id_counter;
```

### Data Quality Checks

```sql
-- Find orders with invalid Order ID format
SELECT id, order_id, created_at
FROM orders
WHERE order_id IS NOT NULL 
  AND order_id !~ '^\d+-\d{4}$'
ORDER BY created_at DESC;

-- Find gaps in counter sequence (should be none)
WITH numbered_orders AS (
  SELECT 
    order_id,
    CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) as counter,
    ROW_NUMBER() OVER (ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) as row_num
  FROM orders
  WHERE order_id ~ '^\d+-\d{4}$'
)
SELECT 
  counter,
  row_num,
  counter - row_num as gap,
  CASE 
    WHEN counter - row_num > 0 THEN 'Missing counter(s)'
    ELSE 'OK'
  END as status
FROM numbered_orders
WHERE counter - row_num != 0;

-- Count orders by year
SELECT 
  SPLIT_PART(order_id, '-', 2) as year,
  COUNT(*) as order_count,
  MIN(CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) as min_counter,
  MAX(CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)) as max_counter
FROM orders
WHERE order_id ~ '^\d+-\d{4}$'
GROUP BY SPLIT_PART(order_id, '-', 2)
ORDER BY year;
```

### Performance Monitoring

```sql
-- Monitor Order ID generation performance
-- (Add timing to your application logs first)

-- Check for slow Order ID queries
SELECT 
  query,
  calls,
  mean_exec_time,
  max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%order_id%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- Monitor sequence usage
SELECT 
  schemaname,
  sequencename,
  last_value,
  increment_by,
  is_called
FROM pg_sequences
WHERE sequencename = 'order_id_counter';
```

### Backup Script

```bash
#!/bin/bash
# backup-orders.sh - Backup orders table before major changes

BACKUP_DIR="/backups/upkeepqr"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/orders_backup_$TIMESTAMP.sql"

mkdir -p $BACKUP_DIR

echo "Backing up orders table..."
pg_dump $DATABASE_URL \
  --table=orders \
  --data-only \
  --file=$BACKUP_FILE

if [ $? -eq 0 ]; then
  echo "‚úÖ Backup created: $BACKUP_FILE"
  
  # Compress backup
  gzip $BACKUP_FILE
  echo "‚úÖ Compressed: ${BACKUP_FILE}.gz"
  
  # Keep only last 30 days of backups
  find $BACKUP_DIR -name "orders_backup_*.sql.gz" -mtime +30 -delete
  echo "‚úÖ Old backups cleaned up"
else
  echo "‚ùå Backup failed!"
  exit 1
fi
```

### Health Check Script

```bash
#!/bin/bash
# check-order-ids.sh - Verify Order ID integrity

echo "=== Order ID Health Check ==="

# Check for duplicates
DUPLICATES=$(psql $DATABASE_URL -t -c "
  SELECT COUNT(*) 
  FROM (
    SELECT order_id 
    FROM orders 
    WHERE order_id IS NOT NULL
    GROUP BY order_id 
    HAVING COUNT(*) > 1
  ) AS dupes;
")

if [ "$DUPLICATES" -gt 0 ]; then
  echo "‚ùå Found $DUPLICATES duplicate Order IDs!"
  exit 1
else
  echo "‚úÖ No duplicate Order IDs"
fi

# Check format validity
INVALID=$(psql $DATABASE_URL -t -c "
  SELECT COUNT(*) 
  FROM orders 
  WHERE order_id IS NOT NULL 
    AND order_id !~ '^\d+-\d{4}$';
")

if [ "$INVALID" -gt 0 ]; then
  echo "‚ö†Ô∏è  Found $INVALID Order IDs with invalid format"
  exit 1
else
  echo "‚úÖ All Order IDs have valid format"
fi

# Check sequence sync
MAX_COUNTER=$(psql $DATABASE_URL -t -c "
  SELECT COALESCE(
    MAX(CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER)),
    0
  )
  FROM orders 
  WHERE order_id ~ '^\d+-\d{4}$';
" | xargs)

SEQ_VALUE=$(psql $DATABASE_URL -t -c "
  SELECT last_value FROM order_id_counter;
" | xargs)

if [ "$SEQ_VALUE" -lt "$MAX_COUNTER" ]; then
  echo "‚ö†Ô∏è  Sequence out of sync! Max counter: $MAX_COUNTER, Sequence: $SEQ_VALUE"
  echo "   Run: SELECT setval('order_id_counter', $MAX_COUNTER);"
  exit 1
else
  echo "‚úÖ Sequence in sync (value: $SEQ_VALUE)"
fi

echo "=== Health Check Complete ==="
```

---

## üìñ REPLIT AGENT PROMPT

Copy and paste this into Replit Agent:

```
TASK: Implement new Order ID format for Magnet Orders

REQUIREMENTS:
1. Change Order ID format to: {counter}-{year}
   - Example: 1-2025, 2-2025, 150-2025
   - Counter increments continuously (never resets)
   - Year is 4-digit format from order creation date

2. Database Changes:
   - Table: orders (PostgreSQL)
   - Add column: order_id VARCHAR(50) UNIQUE NOT NULL
   - Migration script: db/migrations/001_add_order_id_format.sql

3. Backend Implementation:
   - Create: server/utils/orderIdGenerator.ts
   - Function: generateOrderId() returns Promise<string>
   - Logic: Query max counter, increment by 1, append current year
   - Handle edge case: No existing orders (start at 1)
   
4. Integration:
   - Find order creation endpoint (likely POST /api/orders or POST /api/magnets/order)
   - Import generateOrderId function
   - Generate Order ID before INSERT
   - Include order_id in INSERT statement

5. Frontend Update:
   - File: client/src/pages/MagnetDashboard.tsx
   - Ensure "Order ID" column displays order.order_id (not order.id)
   - Add monospace font for Order ID column
   - Update TypeScript types if needed

COUNTER LOGIC:
```sql
-- Get max counter from existing orders
SELECT CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) as counter
FROM orders
WHERE order_id IS NOT NULL
ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER) DESC
LIMIT 1;
```

TESTING:
- Create first order ‚Üí Order ID should be "1-2025"
- Create second order ‚Üí Order ID should be "2-2025"
- Check uniqueness ‚Üí No duplicate Order IDs
- View Magnet Orders page ‚Üí Order IDs display correctly

CRITICAL:
- Counter continues across years (51-2024, then 52-2025)
- Counter NEVER resets to 1 when year changes
- If 50 orders exist, next order is 51-YYYY (not 1-YYYY)
- Year updates based on when order is created

FILES TO CREATE/MODIFY:
1. CREATE: db/migrations/001_add_order_id_format.sql
2. CREATE: server/utils/orderIdGenerator.ts  
3. MODIFY: server/routes.ts (or server/routes/orders.ts)
4. MODIFY: client/src/pages/MagnetDashboard.tsx

Follow specification: SPEC-ORDER-ID-FORMAT.md for complete details.
```

---

## üìö APPENDIX

### A. Example Order IDs

| Counter | Year | Order ID | Notes |
|---------|------|----------|-------|
| 1 | 2025 | 1-2025 | First order ever |
| 2 | 2025 | 2-2025 | Second order in 2025 |
| 50 | 2025 | 50-2025 | 50th order (created in 2025) |
| 51 | 2026 | 51-2026 | 51st order (created in 2026) |
| 100 | 2026 | 100-2026 | 100th order (counter continuous) |
| 365 | 2027 | 365-2027 | 365th order (3 years later) |

### B. Database Query Examples

**Insert Order with New Format:**
```sql
INSERT INTO orders (order_id, customer_name, total_amount, status, created_at)
VALUES ('1-2025', 'John Doe', 29.99, 'new', NOW())
RETURNING *;
```

**Query Orders by Year:**
```sql
SELECT * FROM orders 
WHERE SPLIT_PART(order_id, '-', 2) = '2025'
ORDER BY CAST(SPLIT_PART(order_id, '-', 1) AS INTEGER);
```

**Get Order Count by Year:**
```sql
SELECT 
  SPLIT_PART(order_id, '-', 2) as year,
  COUNT(*) as order_count
FROM orders
WHERE order_id IS NOT NULL
GROUP BY SPLIT_PART(order_id, '-', 2)
ORDER BY year;
```

### C. TypeScript Types

```typescript
// Order type definition
interface Order {
  id: number;                    // Internal database ID
  order_id: string;              // Formatted Order ID: "1-2025"
  customer_name: string;
  customer_email: string;
  total_amount: number;
  status: OrderStatus;
  items: OrderItem[];
  created_at: Date;
  updated_at: Date;
}

type OrderStatus = 'new' | 'paid' | 'in_production' | 'shipped' | 'delivered' | 'canceled' | 'refunded';

interface OrderItem {
  product_sku: string;
  quantity: number;
  price: number;
}
```

---

## üë• CODE OWNERSHIP ‚≠ê NEW

### Development Team

| Role | Name | Responsibility |
|------|------|----------------|
| **Primary Developer** | Replit AI Agent | Initial implementation |
| **Technical Reviewer** | Samuel Fapohunda | Code review, testing verification |
| **Product Owner** | Samuel Fapohunda | Requirements definition, acceptance |
| **QA Engineer** | TBD | Integration testing, load testing |
| **DevOps** | TBD | Deployment, monitoring setup |

### Review Checklist

**Code Review (Technical Reviewer):**
- [ ] Database migration script reviewed and tested
- [ ] Counter generation logic handles edge cases
- [ ] Concurrency control properly implemented
- [ ] Error handling and logging comprehensive
- [ ] TypeScript types correctly defined
- [ ] Frontend displays Order ID correctly
- [ ] No hardcoded values or magic numbers
- [ ] Code follows project style guide

**Security Review:**
- [ ] No SQL injection vulnerabilities
- [ ] Input validation on all user inputs
- [ ] Proper error messages (no sensitive data exposed)
- [ ] Access control enforced (admin-only endpoints)

**Performance Review:**
- [ ] Order ID generation completes in < 100ms
- [ ] Database queries optimized (indexes exist)
- [ ] No N+1 query issues
- [ ] Concurrency test passes (10+ simultaneous orders)

**Documentation Review:**
- [ ] README updated with Order ID format
- [ ] API documentation includes Order ID field
- [ ] Database schema documented
- [ ] Maintenance scripts documented

### Post-Implementation Follow-Up

**Week 1:**
- Monitor error logs for Order ID generation failures
- Check for duplicate Order IDs (should be zero)
- Verify counter sequence is incrementing correctly
- Review performance metrics (< 100ms generation time)

**Week 2-4:**
- Analyze Order ID distribution across time
- Check for any sequence gaps
- Review customer feedback (if any)
- Optimize queries if performance degrades

**Month 2-3:**
- Evaluate if annual counter reset would be beneficial
- Review storage/indexing strategy
- Consider archival strategy for old orders
- Plan for future enhancements (if any)

### Contact Information

For questions or issues with this implementation:

| Issue Type | Contact |
|------------|---------|
| Implementation questions | Replit AI Agent documentation |
| Business logic clarification | Samuel Fapohunda |
| Database issues | DBA or DevOps team |
| Production incidents | On-call engineer |

---

## ‚úÖ SPECIFICATION COMPLETE

**Status:** Ready for Implementation (Enhanced Version 1.1)  
**Complexity:** Medium  
**Risk:** Low-Medium (with proper concurrency controls)  
**Implementation Time:** 2-3 hours (code) + 1 hour (testing)

This specification is **production-ready** with enhancements for:
- ‚úÖ Concurrency control (zero race conditions)
- ‚úÖ Automated test coverage (unit + integration)
- ‚úÖ Fallback/recovery logic
- ‚úÖ Environment validation
- ‚úÖ Maintenance scripts
- ‚úÖ Comprehensive rollback procedures
- ‚úÖ Code ownership and review process

**Next Step:** Copy the Replit Agent prompt from Section "REPLIT AGENT PROMPT" and paste into Replit AI Agent.