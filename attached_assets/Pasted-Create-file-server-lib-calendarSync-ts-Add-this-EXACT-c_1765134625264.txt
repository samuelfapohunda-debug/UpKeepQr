Create file: server/lib/calendarSync.ts

Add this EXACT code:
```typescript
import { google } from 'googleapis';
import { db } from '../db.js';
import { calendarConnectionsTable, calendarSyncEventsTable, householdTaskAssignmentsTable } from '../../shared/schema.js';
import { eq, and } from 'drizzle-orm';
import { decryptToken, encryptToken } from './encryption.js';
import { randomUUID } from 'crypto';

// Get valid access token (handles refresh if needed)
export async function getValidAccessToken(connectionId: string) {
  const connection = await db.query.calendarConnectionsTable.findFirst({
    where: eq(calendarConnectionsTable.id, connectionId),
  });

  if (!connection) {
    throw new Error('Calendar connection not found');
  }

  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET
  );

  // Decrypt tokens
  const accessToken = decryptToken(connection.access_token);
  const refreshToken = decryptToken(connection.refresh_token);

  oauth2Client.setCredentials({
    access_token: accessToken,
    refresh_token: refreshToken,
    expiry_date: connection.token_expiry?.getTime(),
  });

  // Check if token is expired and refresh if needed
  const tokenInfo = await oauth2Client.getTokenInfo(accessToken).catch(() => null);
  
  if (!tokenInfo || (connection.token_expiry && connection.token_expiry < new Date())) {
    console.log('Access token expired, refreshing...');
    const { credentials } = await oauth2Client.refreshAccessToken();
    
    if (credentials.access_token) {
      // Update stored tokens
      await db.update(calendarConnectionsTable)
        .set({
          access_token: encryptToken(credentials.access_token),
          token_expiry: credentials.expiry_date ? new Date(credentials.expiry_date) : null,
        })
        .where(eq(calendarConnectionsTable.id, connectionId));
      
      oauth2Client.setCredentials(credentials);
    }
  }

  return oauth2Client;
}

// Sync household tasks to Google Calendar
export async function syncTasksToCalendar(householdId: string) {
  console.log(`Starting calendar sync for household: ${householdId}`);

  // Get calendar connection
  const connection = await db.query.calendarConnectionsTable.findFirst({
    where: and(
      eq(calendarConnectionsTable.household_id, householdId),
      eq(calendarConnectionsTable.sync_enabled, true)
    ),
  });

  if (!connection) {
    console.log('No active calendar connection found');
    return { success: false, message: 'No calendar connection' };
  }

  // Get valid OAuth client
  const oauth2Client = await getValidAccessToken(connection.id);
  const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

  // Get pending tasks
  const tasks = await db.query.householdTaskAssignmentsTable.findMany({
    where: and(
      eq(householdTaskAssignmentsTable.household_id, householdId),
      eq(householdTaskAssignmentsTable.status, 'pending')
    ),
  });

  console.log(`Found ${tasks.length} pending tasks to sync`);

  let created = 0;
  let skipped = 0;

  for (const task of tasks) {
    // Check if already synced
    const existingEvent = await db.query.calendarSyncEventsTable.findFirst({
      where: and(
        eq(calendarSyncEventsTable.connection_id, connection.id),
        eq(calendarSyncEventsTable.task_id, task.id)
      ),
    });

    if (existingEvent) {
      console.log(`Task ${task.id} already synced, skipping`);
      skipped++;
      continue;
    }

    // Create calendar event
    const eventStart = new Date(task.due_date);
    const eventEnd = new Date(eventStart.getTime() + 60 * 60 * 1000); // 1 hour duration

    const event = {
      summary: `Home Maintenance Task - ${task.frequency || 'One-time'}`,
      description: `Task ID: ${task.id}\nPriority: ${task.priority}\nFrequency: ${task.frequency}\n\nView in UpKeepQR: ${process.env.FRONTEND_URL}/dashboard`,
      start: {
        dateTime: eventStart.toISOString(),
        timeZone: connection.calendar_timezone,
      },
      end: {
        dateTime: eventEnd.toISOString(),
        timeZone: connection.calendar_timezone,
      },
      reminders: {
        useDefault: false,
        overrides: [{ method: 'popup', minutes: 60 }],
      },
      colorId: '7', // Blue
    };

    try {
      const response = await calendar.events.insert({
        calendarId: connection.calendar_id,
        requestBody: event,
      });

      // Save sync record
      await db.insert(calendarSyncEventsTable).values({
        id: randomUUID(),
        connection_id: connection.id,
        household_id: householdId,
        task_id: task.id,
        task_title: event.summary,
        google_event_id: response.data.id!,
        event_start: eventStart,
        event_end: eventEnd,
        event_status: 'scheduled',
        sync_status: 'synced',
      });

      created++;
      console.log(`✅ Created calendar event for task ${task.id}`);
    } catch (error: any) {
      console.error(`❌ Failed to create event for task ${task.id}:`, error.message);
    }
  }

  await db.update(calendarConnectionsTable)
    .set({
      last_sync: new Date(),
      last_sync_status: 'success',
    })
    .where(eq(calendarConnectionsTable.id, connection.id));

  console.log(`Sync complete: ${created} created, ${skipped} skipped`);
  return { success: true, created, skipped };
}
```

Rules:
- Create ONLY this file
- DO NOT modify any other files yet