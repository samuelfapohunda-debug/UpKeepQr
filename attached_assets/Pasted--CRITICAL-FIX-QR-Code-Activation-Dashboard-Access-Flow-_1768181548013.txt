# üîß CRITICAL FIX: QR Code Activation & Dashboard Access Flow

## üö® PROBLEM IDENTIFIED

**Current Broken Flow:**
User scans QR ‚Üí Always goes to setup ‚Üí Creates duplicate households

**Issues:**
1. ‚ùå QR codes can be scanned multiple times to create duplicate households
2. ‚ùå After activation, scanning QR again goes to setup (not dashboard)
3. ‚ùå No proper distinction between "first-time activation" vs "returning user"
4. ‚ùå Users can't get back to their dashboard after first scan

---

## ‚úÖ CORRECT FLOW SPECIFICATION

### Two Distinct User States:

**State 1: QR Code NOT YET ACTIVATED (First Scan)**
```
User scans QR magnet ‚Üí
  ‚Üì
Reads activation code from QR ‚Üí
  ‚Üì
Redirects to /setup/{ACTIVATION_CODE} ‚Üí
  ‚Üì
Shows setup form (email, name, address) ‚Üí
  ‚Üì
User submits form ‚Üí
  ‚Üì
Backend creates household ‚Üí
  ‚Üì
Backend marks QR as "activated" ‚Üí
  ‚Üì
Backend sends magic link to email ‚Üí
  ‚Üì
Redirects to "Check Your Email" page
```

**State 2: QR Code ALREADY ACTIVATED (Subsequent Scans)**
```
User scans QR magnet ‚Üí
  ‚Üì
Reads activation code from QR ‚Üí
  ‚Üì
Backend checks: Is this QR activated? YES ‚Üí
  ‚Üì
Backend sends magic link to email on file ‚Üí
  ‚Üì
Redirects to "Check Your Email" page ‚Üí
  ‚Üì
User clicks magic link ‚Üí
  ‚Üì
Dashboard loads with user's household data
```

---

## üéØ IMPLEMENTATION SPECIFICATION

### 1. Database Schema Requirements

**Table: `order_magnet_items`** (should already exist)
```sql
-- Verify this table has these fields:
CREATE TABLE order_magnet_items (
  id SERIAL PRIMARY KEY,
  order_id INTEGER,
  activation_code TEXT UNIQUE NOT NULL,
  qr_url TEXT,
  activation_status TEXT DEFAULT 'inactive', -- 'inactive' or 'active'
  activated_at TIMESTAMP,
  activated_by_email TEXT, -- Email of person who activated
  household_id INTEGER REFERENCES households(id), -- Link to household
  created_at TIMESTAMP DEFAULT NOW()
);
```

**Key Fields:**
- `activation_status`: 'inactive' (never used) or 'active' (already activated)
- `activated_by_email`: Email address of the homeowner who activated
- `household_id`: Foreign key to the household this QR belongs to
- `activated_at`: Timestamp of first activation

---

### 2. QR Code Scan Endpoint Logic

**File to Modify:** `server/src/routes/setup.ts`

**Endpoint:** `GET /api/setup/{ACTIVATION_CODE}` or similar

**Current Logic (WRONG):**
```typescript
// ‚ùå CURRENT - Always shows setup form
router.get('/setup/:code', async (req, res) => {
  const { code } = req.params;
  
  // Just show setup form regardless of activation status
  return res.render('setup-form', { code });
});
```

**New Logic (CORRECT):**
```typescript
// ‚úÖ NEW - Check activation status first
router.get('/setup/:code', async (req, res) => {
  const { code } = req.params;
  
  // 1. Look up the QR code in database
  const qrCode = await db
    .select()
    .from(orderMagnetItemsTable)
    .where(eq(orderMagnetItemsTable.activationCode, code))
    .limit(1);
  
  // 2. If code doesn't exist
  if (!qrCode || qrCode.length === 0) {
    return res.status(404).json({ 
      error: 'Invalid activation code' 
    });
  }
  
  const magnet = qrCode[0];
  
  // 3. Check if already activated
  if (magnet.activationStatus === 'active') {
    // QR IS ALREADY ACTIVATED
    
    // Send magic link to the email on file
    const email = magnet.activatedByEmail;
    const magicLink = await generateMagicLink(email, magnet.householdId);
    
    await sendMagicLinkEmail(email, magicLink);
    
    // Redirect to "check your email" page
    return res.redirect('/check-email?message=magic-link-sent');
  }
  
  // 4. QR is NOT activated - show setup form
  // This is a first-time activation
  return res.json({ 
    status: 'inactive',
    activationCode: code,
    // Frontend should show setup form
  });
});
```

---

### 3. Setup Form Submission Logic

**File to Modify:** `server/src/routes/setup.ts`

**Endpoint:** `POST /api/setup/activate`

**New Logic:**
```typescript
router.post('/api/setup/activate', async (req, res) => {
  const { 
    activationCode, 
    email, 
    name, 
    address 
  } = req.body;
  
  try {
    // 1. Verify code exists and is inactive
    const qrCode = await db
      .select()
      .from(orderMagnetItemsTable)
      .where(eq(orderMagnetItemsTable.activationCode, activationCode))
      .limit(1);
    
    if (!qrCode || qrCode.length === 0) {
      return res.status(404).json({ error: 'Invalid activation code' });
    }
    
    const magnet = qrCode[0];
    
    // 2. Check if already activated (prevent race conditions)
    if (magnet.activationStatus === 'active') {
      return res.status(400).json({ 
        error: 'This QR code has already been activated',
        activatedBy: magnet.activatedByEmail 
      });
    }
    
    // 3. Use transaction to ensure atomicity
    const result = await db.transaction(async (tx) => {
      
      // 3a. Create or get user
      let user = await tx
        .select()
        .from(usersTable)
        .where(eq(usersTable.email, email))
        .limit(1);
      
      if (!user || user.length === 0) {
        user = await tx
          .insert(usersTable)
          .values({ 
            email, 
            name,
            role: 'homeowner' 
          })
          .returning();
      }
      
      const userId = user[0].id;
      
      // 3b. Create household
      const household = await tx
        .insert(householdsTable)
        .values({
          userId,
          name: `${name}'s Home`,
          address: address.street,
          city: address.city,
          state: address.state,
          zip: address.zip
        })
        .returning();
      
      const householdId = household[0].id;
      
      // 3c. Mark QR as activated (CRITICAL - prevents reuse)
      await tx
        .update(orderMagnetItemsTable)
        .set({
          activationStatus: 'active',
          activatedAt: new Date(),
          activatedByEmail: email,
          householdId: householdId
        })
        .where(eq(orderMagnetItemsTable.activationCode, activationCode));
      
      // 3d. Create default maintenance schedule for household
      await createMaintenanceSchedule(tx, householdId, address);
      
      return { userId, householdId, email };
    });
    
    // 4. Send magic link to access dashboard
    const magicLink = await generateMagicLink(result.email, result.householdId);
    await sendMagicLinkEmail(result.email, magicLink);
    
    // 5. Return success
    return res.json({ 
      success: true,
      message: 'Activation successful! Check your email for dashboard access.',
      email: result.email 
    });
    
  } catch (error) {
    console.error('Activation error:', error);
    return res.status(500).json({ 
      error: 'Failed to activate QR code' 
    });
  }
});
```

---

### 4. Magic Link Generation

**File to Create/Modify:** `server/lib/magicLink.ts`

```typescript
import { nanoid } from 'nanoid';
import { db } from '../db';
import { magicLinksTable } from '@shared/schema';

/**
 * Generate a magic link token for dashboard access
 */
export async function generateMagicLink(
  email: string, 
  householdId: number
): Promise<string> {
  
  // Generate secure random token
  const token = nanoid(32);
  
  // Set expiration (24 hours from now)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 24);
  
  // Store in database
  await db.insert(magicLinksTable).values({
    token,
    email,
    householdId,
    expiresAt,
    used: false
  });
  
  // Return full magic link URL
  const baseUrl = process.env.PUBLIC_BASE_URL || 'https://upkeepqr.com';
  return `${baseUrl}/auth/magic?token=${token}`;
}

/**
 * Verify and consume a magic link token
 */
export async function verifyMagicLink(token: string) {
  
  // Look up token
  const links = await db
    .select()
    .from(magicLinksTable)
    .where(eq(magicLinksTable.token, token))
    .limit(1);
  
  if (!links || links.length === 0) {
    throw new Error('Invalid magic link');
  }
  
  const link = links[0];
  
  // Check if already used
  if (link.used) {
    throw new Error('Magic link already used');
  }
  
  // Check if expired
  if (new Date() > link.expiresAt) {
    throw new Error('Magic link expired');
  }
  
  // Mark as used (one-time use)
  await db
    .update(magicLinksTable)
    .set({ used: true, usedAt: new Date() })
    .where(eq(magicLinksTable.token, token));
  
  return {
    email: link.email,
    householdId: link.householdId
  };
}
```

---

### 5. Magic Links Database Table

**File to Modify:** `shared/schema.ts`

```typescript
// Add this table to your schema

export const magicLinksTable = pgTable('magic_links', {
  id: serial('id').primaryKey(),
  token: text('token').unique().notNull(),
  email: text('email').notNull(),
  householdId: integer('household_id').references(() => householdsTable.id),
  expiresAt: timestamp('expires_at').notNull(),
  used: boolean('used').default(false),
  usedAt: timestamp('used_at'),
  createdAt: timestamp('created_at').defaultNow()
});
```

**Migration to run:**
```sql
CREATE TABLE IF NOT EXISTS magic_links (
  id SERIAL PRIMARY KEY,
  token TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  household_id INTEGER REFERENCES households(id),
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Create index for faster lookups
CREATE INDEX idx_magic_links_token ON magic_links(token);
CREATE INDEX idx_magic_links_email ON magic_links(email);
```

---

### 6. Magic Link Authentication Endpoint

**File to Create:** `server/src/routes/auth.ts`

```typescript
import { Router } from 'express';
import { verifyMagicLink } from '../lib/magicLink';

const router = Router();

/**
 * GET /auth/magic?token={TOKEN}
 * 
 * Verify magic link and redirect to dashboard
 */
router.get('/auth/magic', async (req, res) => {
  const { token } = req.query;
  
  if (!token || typeof token !== 'string') {
    return res.redirect('/error?message=invalid-link');
  }
  
  try {
    // Verify and consume magic link
    const { email, householdId } = await verifyMagicLink(token);
    
    // Create session token for dashboard access
    const sessionToken = nanoid(32);
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30); // 30 days
    
    // Store session
    await db.insert(sessionsTable).values({
      token: sessionToken,
      email,
      householdId,
      expiresAt
    });
    
    // Redirect to dashboard with session token
    return res.redirect(`/dashboard?token=${sessionToken}`);
    
  } catch (error) {
    console.error('Magic link error:', error);
    
    // Redirect to error page with appropriate message
    const message = error.message.includes('expired') 
      ? 'link-expired' 
      : error.message.includes('used')
      ? 'link-already-used'
      : 'invalid-link';
      
    return res.redirect(`/error?message=${message}`);
  }
});

export default router;
```

---

### 7. Sessions Table for Dashboard Access

**Add to schema:**
```typescript
export const sessionsTable = pgTable('sessions', {
  id: serial('id').primaryKey(),
  token: text('token').unique().notNull(),
  email: text('email').notNull(),
  householdId: integer('household_id').references(() => householdsTable.id),
  expiresAt: timestamp('expires_at').notNull(),
  createdAt: timestamp('created_at').defaultNow()
});
```

**Migration:**
```sql
CREATE TABLE IF NOT EXISTS sessions (
  id SERIAL PRIMARY KEY,
  token TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  household_id INTEGER REFERENCES households(id),
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_email ON sessions(email);
```

---

### 8. Frontend QR Scan Flow

**File to Modify:** `client/src/pages/Setup.tsx`

```tsx
import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';

export default function Setup() {
  const { code } = useParams<{ code: string }>();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(true);
  const [alreadyActivated, setAlreadyActivated] = useState(false);
  
  useEffect(() => {
    if (!code) {
      navigate('/');
      return;
    }
    
    checkActivationStatus();
  }, [code]);
  
  const checkActivationStatus = async () => {
    try {
      const response = await fetch(`/api/setup/${code}`);
      
      // If redirected, it means QR is already activated
      if (response.redirected) {
        setAlreadyActivated(true);
        setLoading(false);
        return;
      }
      
      const data = await response.json();
      
      if (data.status === 'inactive') {
        // Show setup form
        setLoading(false);
      } else if (data.status === 'active') {
        // Already activated - magic link sent
        setAlreadyActivated(true);
        setLoading(false);
      }
      
    } catch (error) {
      console.error('Error checking activation:', error);
      setLoading(false);
    }
  };
  
  // Loading state
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-emerald-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-600">Checking your QR code...</p>
        </div>
      </div>
    );
  }
  
  // Already activated state
  if (alreadyActivated) {
    return (
      <div className="min-h-screen flex items-center justify-center px-4">
        <div className="max-w-md text-center">
          <div className="text-6xl mb-6">üìß</div>
          <h1 className="text-2xl font-bold text-gray-900 mb-4">
            Check Your Email
          </h1>
          <p className="text-gray-600 mb-6">
            This QR code is already activated! We've sent a magic link to your email 
            so you can access your dashboard.
          </p>
          <div className="bg-emerald-50 border border-emerald-200 rounded-lg p-4 text-left">
            <p className="text-sm text-emerald-900">
              <strong>Tip:</strong> Check your spam folder if you don't see the email 
              within a few minutes.
            </p>
          </div>
        </div>
      </div>
    );
  }
  
  // First-time activation - show setup form
  return (
    <div className="min-h-screen bg-gray-50 py-12 px-4">
      <div className="max-w-md mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            Welcome to UpKeepQR!
          </h1>
          <p className="text-gray-600">
            Let's set up your home maintenance dashboard
          </p>
        </div>
        
        <SetupForm activationCode={code} />
      </div>
    </div>
  );
}
```

---

### 9. Updated Email Templates

**File to Create:** `server/lib/emailTemplates.ts`

```typescript
/**
 * Magic link email for dashboard access
 */
export function magicLinkEmailTemplate(
  name: string,
  magicLink: string,
  isFirstTime: boolean
) {
  const subject = isFirstTime 
    ? 'Welcome to UpKeepQR! Access Your Dashboard'
    : 'Access Your UpKeepQR Dashboard';
  
  const greeting = isFirstTime
    ? `Welcome to UpKeepQR, ${name}!`
    : `Hi ${name},`;
  
  const message = isFirstTime
    ? `Your home maintenance dashboard is ready! Click the link below to access it and see your personalized maintenance schedule.`
    : `You requested access to your dashboard. Click the link below to continue.`;
  
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
      <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
        <h1 style="color: #10b981;">${greeting}</h1>
        
        <p>${message}</p>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="${magicLink}" 
             style="display: inline-block; background: #10b981; color: white; padding: 16px 32px; text-decoration: none; border-radius: 8px; font-weight: 600;">
            Access Dashboard
          </a>
        </div>
        
        <p style="color: #666; font-size: 14px;">
          This link will expire in 24 hours and can only be used once.
        </p>
        
        <p style="color: #666; font-size: 14px;">
          If you didn't request this, you can safely ignore this email.
        </p>
        
        <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 30px 0;">
        
        <p style="color: #999; font-size: 12px;">
          UpKeepQR - Your Home's Maintenance, Automated<br>
          Questions? Reply to this email or visit upkeepqr.com/support
        </p>
      </div>
    </body>
    </html>
  `;
  
  const text = `
${greeting}

${message}

Access your dashboard: ${magicLink}

This link will expire in 24 hours and can only be used once.

If you didn't request this, you can safely ignore this email.

---
UpKeepQR - Your Home's Maintenance, Automated
Questions? Reply to this email or visit upkeepqr.com/support
  `;
  
  return { subject, html, text };
}
```

---

## üìä COMPLETE USER FLOW DIAGRAMS

### First-Time User (QR Never Activated):
```
1. User scans QR magnet
   ‚Üì
2. QR contains: upkeepqr.com/setup/ABC123DEF456
   ‚Üì
3. Browser opens URL
   ‚Üì
4. Backend checks: Is ABC123DEF456 activated? NO
   ‚Üì
5. Frontend shows setup form
   ‚Üì
6. User enters: email, name, address
   ‚Üì
7. Backend:
   - Creates user (if not exists)
   - Creates household
   - Marks QR as "active"
   - Links QR to household
   - Stores activatedByEmail
   ‚Üì
8. Backend generates magic link
   ‚Üì
9. Backend sends email with magic link
   ‚Üì
10. Frontend shows "Check Your Email" page
    ‚Üì
11. User clicks magic link in email
    ‚Üì
12. Backend verifies magic link
    ‚Üì
13. Backend creates 30-day session token
    ‚Üì
14. Redirects to /dashboard?token={SESSION_TOKEN}
    ‚Üì
15. Dashboard loads with user's data
```

### Returning User (QR Already Activated):
```
1. User scans same QR magnet
   ‚Üì
2. QR contains: upkeepqr.com/setup/ABC123DEF456
   ‚Üì
3. Browser opens URL
   ‚Üì
4. Backend checks: Is ABC123DEF456 activated? YES
   ‚Üì
5. Backend gets activatedByEmail from database
   ‚Üì
6. Backend generates fresh magic link
   ‚Üì
7. Backend sends email to activatedByEmail
   ‚Üì
8. Frontend shows "Check Your Email" page
   ‚Üì
9. User clicks magic link in email
   ‚Üì
10. Backend verifies magic link
    ‚Üì
11. Backend creates 30-day session token
    ‚Üì
12. Redirects to /dashboard?token={SESSION_TOKEN}
    ‚Üì
13. Dashboard loads with user's existing data
```

---

## ‚úÖ IMPLEMENTATION CHECKLIST

### Backend Changes:
- [ ] Add `magic_links` table to database
- [ ] Add `sessions` table to database
- [ ] Create `magicLink.ts` utility file
- [ ] Update `/api/setup/:code` endpoint to check activation status
- [ ] Update `/api/setup/activate` to prevent re-activation
- [ ] Create `/auth/magic` endpoint for magic link verification
- [ ] Update email templates for magic links
- [ ] Add indexes to magic_links and sessions tables

### Frontend Changes:
- [ ] Update `Setup.tsx` to check activation status first
- [ ] Add "Check Your Email" page/state
- [ ] Add error page for invalid/expired magic links
- [ ] Update QR code to include proper URL format

### Testing:
- [ ] Test first-time QR activation
- [ ] Test scanning already-activated QR
- [ ] Test magic link email delivery
- [ ] Test magic link expiration (24 hours)
- [ ] Test magic link one-time use
- [ ] Test session token creation
- [ ] Test dashboard access with session token

---

## üéØ ACCEPTANCE CRITERIA

The QR flow is correct when:

1. ‚úÖ First scan of QR ‚Üí Setup form appears
2. ‚úÖ Setup submission ‚Üí QR marked as "active" forever
3. ‚úÖ Second scan of same QR ‚Üí "Check email" message (no duplicate household)
4. ‚úÖ Magic link in email ‚Üí Dashboard access
5. ‚úÖ Magic link expires after 24 hours
6. ‚úÖ Magic link can only be used once
7. ‚úÖ Session lasts 30 days
8. ‚úÖ No way to create duplicate households with same QR

---

## üö® CRITICAL SECURITY NOTES

**QR Activation Security:**
- Use database transaction for activation (prevents race conditions)
- Check activation status BEFORE allowing setup
- Mark QR as "active" atomically (one household per QR, forever)

**Magic Link Security:**
- Generate cryptographically secure tokens (nanoid or crypto.randomBytes)
- Expire after 24 hours
- One-time use only (mark as "used" after verification)
- Store in database, not JWT (allows invalidation)

**Session Security:**
- Generate new session token after magic link verification
- Sessions last 30 days (configurable)
- Store in database (allows remote logout if needed)
- Include household ID in session (for authorization)

---

## üìù SQL MIGRATION SCRIPT

**Run this to update your database:**

```sql
-- Magic Links table
CREATE TABLE IF NOT EXISTS magic_links (
  id SERIAL PRIMARY KEY,
  token TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  household_id INTEGER REFERENCES households(id),
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_magic_links_token ON magic_links(token);
CREATE INDEX idx_magic_links_email ON magic_links(email);

-- Sessions table
CREATE TABLE IF NOT EXISTS sessions (
  id SERIAL PRIMARY KEY,
  token TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  household_id INTEGER REFERENCES households(id),
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_email ON sessions(email);

-- Update order_magnet_items if needed
ALTER TABLE order_magnet_items 
  ADD COLUMN IF NOT EXISTS household_id INTEGER REFERENCES households(id);

ALTER TABLE order_magnet_items 
  ADD COLUMN IF NOT EXISTS activated_by_email TEXT;
```

---

## üéä RESULT

After this fix:
- ‚úÖ QR codes are one-time activation only
- ‚úÖ Re-scanning sends magic link (no duplicate households)
- ‚úÖ Secure magic link authentication
- ‚úÖ 30-day sessions for dashboard access
- ‚úÖ Proper email-based authentication flow
- ‚úÖ No passwords needed (magic links)

---

**END OF SPECIFICATION**

*Critical Fix Created: January 10, 2026*
*Status: Ready for Implementation*
*Priority: CRITICAL (blocks correct user flow)*